<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>jdbc的使用</title>
    <url>/2022/07/15/SpringDataJdbc%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="命名查询"><a href="#命名查询" class="headerlink" title="命名查询"></a>命名查询</h3><p>spring data jdbc最底层的接口是Repository</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Repository</span>&lt;T, ID&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次是CrudRepository，其继承Repository接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CrudRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;T, ID&gt; &#123;</span><br><span class="line"><span class="comment">//里面有很多定义好的方法</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是PagingAndSortingRepository，其继承CrudRepository</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PagingAndSortingRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;T, ID&gt; &#123;</span><br><span class="line"><span class="comment">//比CrudRepository多了分页和排序的方法</span></span><br><span class="line">Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Sort sort)</span>;</span><br><span class="line">Page&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Pageable pageable)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种使用方法就是自定义Repository接口，继承PagingAndSortingRepository接口，然后可以使用其默认的实现好的方法，只要按照其规定好的方法格式，框架会帮我们生成sql语句，与数据库交互，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">JobRepository</span> <span class="keyword">extends</span> <span class="title class_">PagingAndSortingRepository</span>&lt;Job, Long&gt; &#123;</span><br><span class="line">	<span class="comment">//根据工作id查询工作</span></span><br><span class="line">  List&lt;Job&gt; <span class="title function_">findByJobId</span><span class="params">(<span class="type">long</span> jobId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Table(&quot;job&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> jobId;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>官网提供了一些其他的形象查询方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">&gt;List&lt;Person&gt; <span class="title function_">findByEmailAddressAndLastname</span><span class="params">(EmailAddress emailAddress, String lastname)</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Enables the distinct flag for the query</span></span><br><span class="line">&gt;List&lt;Person&gt; <span class="title function_">findDistinctPeopleByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span>;</span><br><span class="line">&gt;List&lt;Person&gt; <span class="title function_">findPeopleDistinctByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Enabling ignoring case for an individual property</span></span><br><span class="line">&gt;List&lt;Person&gt; <span class="title function_">findByLastnameIgnoreCase</span><span class="params">(String lastname)</span>;</span><br><span class="line">&gt;<span class="comment">// Enabling ignoring case for all suitable properties</span></span><br><span class="line">&gt;List&lt;Person&gt; <span class="title function_">findByLastnameAndFirstnameAllIgnoreCase</span><span class="params">(String lastname, String firstname)</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Enabling static ORDER BY for a query</span></span><br><span class="line">&gt;List&lt;Person&gt; <span class="title function_">findByLastnameOrderByFirstnameAsc</span><span class="params">(String lastname)</span>;</span><br><span class="line">&gt;List&lt;Person&gt; <span class="title function_">findByLastnameOrderByFirstnameDesc</span><span class="params">(String lastname)</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>同时也支持<strong>嵌套属性</strong>的查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;List&lt;Person&gt; <span class="title function_">findByAddress_ZipCode</span><span class="params">(ZipCode zipCode)</span>;</span><br></pre></td></tr></table></figure>

<p>同时除了我们传入的实体类的属性，Spring Data Jdbc还识别 <strong>Page ， Sort</strong> 等参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;Page&lt;User&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">&gt;Slice&lt;User&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">&gt;List&lt;User&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname, Sort sort)</span>;</span><br><span class="line"></span><br><span class="line">&gt;List&lt;User&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;firstname&quot;</span>).ascending()</span><br><span class="line">&gt;.and(Sort.by(<span class="string">&quot;lastname&quot;</span>).descending());</span><br><span class="line">&gt;<span class="comment">//当然也可以这样，更加地安全</span></span><br><span class="line">&gt;TypedSort&lt;Person&gt; person = Sort.sort(Person.class);</span><br><span class="line">&gt;<span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> person.by(Person::getFirstname).ascending()</span><br><span class="line">&gt;.and(person.by(Person::getLastname).descending());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;Pageable pageable=PageRequest.of(<span class="number">1</span>, <span class="number">20</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>甚至可以<strong>限制查询个数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;Page&lt;User&gt; <span class="title function_">queryFirst10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">&gt;Slice&lt;User&gt; <span class="title function_">findTop3ByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">&gt;List&lt;User&gt; <span class="title function_">findFirst10ByLastname</span><span class="params">(String lastname, Sort sort)</span>;</span><br><span class="line"></span><br><span class="line">&gt;List&lt;User&gt; <span class="title function_">findTop10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>返回类型 <code>Streamable</code>    <code>Iterable</code>  <code>Collections </code>  <code>Stream</code>可以自定义</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//Streamable和StreamStream的区别在于Stream必须关闭</span></span><br><span class="line">&gt;<span class="keyword">try</span> (Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) &#123;</span><br><span class="line">&gt;stream.forEach(…);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;Streamable&lt;Person&gt; result = repository.findByFirstnameContaining(<span class="string">&quot;av&quot;</span>)</span><br><span class="line">&gt;.and(repository.findByLastnameContaining(<span class="string">&quot;ea&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>空值</strong>的指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">&gt;<span class="comment">//入参和返回值有一个为空，抛出异常IllegalArgumentException </span></span><br><span class="line">&gt;User <span class="title function_">getByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span>;    </span><br><span class="line">&gt;<span class="comment">//入参和返回值均可以是null</span></span><br><span class="line">&gt;<span class="meta">@Nullable</span></span><br><span class="line">&gt;User <span class="title function_">findByEmailAddress</span><span class="params">(<span class="meta">@Nullable</span> EmailAddress emailAdress)</span>;</span><br><span class="line">&gt;<span class="comment">//没有查询到返回Optional.empty()，但是入参为空时抛出异常IllegalArgumentException </span></span><br><span class="line">&gt;Optional&lt;User&gt; <span class="title function_">findOptionalByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span>; </span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>异步返回</strong>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">@Async</span></span><br><span class="line">&gt;Future&lt;User&gt; <span class="title function_">findByFirstname</span><span class="params">(String firstname)</span>;               </span><br><span class="line"></span><br><span class="line">&gt;<span class="meta">@Async</span></span><br><span class="line">&gt;CompletableFuture&lt;User&gt; <span class="title function_">findOneByFirstname</span><span class="params">(String firstname)</span>; </span><br><span class="line"></span><br><span class="line">&gt;<span class="meta">@Async</span></span><br><span class="line">&gt;ListenableFuture&lt;User&gt; <span class="title function_">findOneByLastname</span><span class="params">(String lastname)</span>; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Query注解"><a href="#Query注解" class="headerlink" title="@Query注解"></a>@Query注解</h3><p>优先注解查询，没有注解去找命名查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select firstName, lastName from User u where u.emailAddress = :email&quot;)</span></span><br><span class="line">  User <span class="title function_">findByEmailAddress</span><span class="params">(<span class="meta">@Param(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以使用 @Modifying on 查询方法将查询标记为修改查询，如以下示例所示</span></span><br><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query(&quot;UPDATE DUMMYENTITY SET name = :name WHERE id = :id&quot;)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateName</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="jdbcTempalte"><a href="#jdbcTempalte" class="headerlink" title="jdbcTempalte"></a>jdbcTempalte</h3><p><a href>参考文章</a>(<a href="https://www.cnblogs.com/wenxuehai/p/14716372.html">https://www.cnblogs.com/wenxuehai/p/14716372.html</a>)</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><blockquote>
<p>JdbcTemplate 是 Spring 对 JDBC 的封装，目的是使JDBC更加易于使用，JdbcTemplate是Spring的一部分。JdbcTemplate 处理了资源的建立和释放，它帮助我们避免一些常见的错误，比如忘了总要关闭连接。他运行核心的JDBC工作流，如Statement的建立和执行，而我们只需要提供SQL语句和提取结果即可。</p>
<p>Spring为了简化数据库访问，主要做了以下几点工作：</p>
<ul>
<li>提供了简化的访问JDBC的模板类，不必手动释放资源；</li>
<li>提供了一个统一的 DAO 类以实现 Data Access Object 模式；</li>
<li>把<code>SQLException</code>封装为<code>DataAccessException</code>，这个异常是一个<code>RuntimeException</code>，并且让我们能区分SQL异常的原因，例如，<code>DuplicateKeyException</code>表示违反了一个唯一约束；</li>
<li>能方便地集成Hibernate、JPA和MyBatis这些数据库访问框架。</li>
</ul>
</blockquote>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><blockquote>
<p>jdbcTemplate主要提供的5类方法及使用：</p>
<p>（1）execute() 方法：可以执行任何SQL语句，一般用于执行DDL语句。</p>
<p>（2）update(sqlStr, 参数列表) 方法：用于执行新增、修改、删除等语句。</p>
<p>（3）batchUpdate() 方法：用于执行批处理相关语句，batchUpdate方法第二参数是一个元素为 Object[] 数组类型的 List 集合。</p>
<p>（4）query() 方法及 queryForXXX() 方法：用于执行查询相关语句，查询结果为基本数据类型或者是单个对象一般使用 queryForObject()</p>
<ul>
<li>queryForInt()：查询一行数据并返回 int 型结果。例子：jdbcTemplate.queryForInt(“select count(*) from user”)</li>
<li>queryForObject(sqlStr, 指定的数据类型, 参数列表)：查询一行任何类型的数据，最后一个参数指定返回结果类型。例子：jdbcTemplate.queryForObject(“selct count(*) from user”, Integer.class)</li>
<li>queryForMap(sqlStr, 参数列表)：查询一行数据并将该行数据转换为 Map 返回。将会将列名作为key，列值作为 value 封装成 map。当查询出来的行数大于1时会报错。例子：jdbcTemplate.queryForMap(“select * from user where username = ?”, “aaa”);``</li>
<li>List&lt;Map&lt;String, Object&gt;&gt; queryForList(sqlStr, 参数列表)：将查询结果集封装为 list 集合，该集合的每一条元素都是一个 map。</li>
<li>query(sqlStr, RowMapper对象, 参数列表)：查询多行数据，并将结果集封装为元素是 JavaBean 的 list。（注意，指定的JavaBean的属性最好不要是基本类型，因为查询出来的结果可能是null，而null赋值为基本数据类型将会报错。比如int最好定义为Integer）</li>
</ul>
<p>（5）call() 方法：用于执行存储过程、函数相关语句。</p>
</blockquote>
<h4 id="具体方法介绍"><a href="#具体方法介绍" class="headerlink" title="具体方法介绍"></a>具体方法介绍</h4><h5 id="增"><a href="#增" class="headerlink" title="增"></a>增</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单个新增</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="comment">//注入JdbcTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">//创建SQL语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user values(?, ?, ?)&quot;</span>;</span><br><span class="line">        <span class="comment">//调用方法执行SQL</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">updateRow</span> <span class="operator">=</span> jdbcTemplate.update(sql, user.getId(), user.getName(), user.getPassword());</span><br><span class="line">        </span><br><span class="line">        System.out.println(updateRow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量新增</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="comment">//注入JdbcTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBath</span><span class="params">(List&lt;Object[]&gt; userList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user values(?, ?, ?)&quot;</span>;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        List&lt;Object[]&gt; userList = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        Object[] arr1 = &#123;1, &quot;name1&quot;, &quot;password1&quot;&#125;;</span></span><br><span class="line"><span class="comment">        Object[] arr2 = &#123;2, &quot;name2&quot;, &quot;password2&quot;&#125;;</span></span><br><span class="line"><span class="comment">        Object[] arr3 = &#123;3, &quot;name3&quot;, &quot;password3&quot;&#125;;</span></span><br><span class="line"><span class="comment">        userList.add(arr1);</span></span><br><span class="line"><span class="comment">        userList.add(arr2);</span></span><br><span class="line"><span class="comment">        userList.add(arr3);</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql, userList);  <span class="comment">//batchUpdate方法第二个参数是集合，该集合元素是数组，数组里面的每个值对应着添加到数据库表里面的字段值。该方法返回影响行数数组</span></span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="改删"><a href="#改删" class="headerlink" title="改删"></a>改删</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单个修改 删除</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="comment">//注入JdbcTemplate</span></span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set name=?, password=? where id=?&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">updateRow</span> <span class="operator">=</span> jdbcTemplate.update(sql, user.getName(), user.getPassword(), user.getId());</span><br><span class="line">        System.out.println(updateRow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from user where id=?&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">updateRow</span> <span class="operator">=</span> jdbcTemplate.update(sql, userId);</span><br><span class="line">        System.out.println(updateRow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量修改 删除</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="comment">//注入JdbcTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="comment">//批量修改</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBatch</span><span class="params">(List&lt;Object[]&gt; listArg)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set name=?, password=? where id=?&quot;</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        List&lt;Object[]&gt; userList = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        Object[] arr1 = &#123;1, &quot;name1&quot;, &quot;password1&quot;&#125;;</span></span><br><span class="line"><span class="comment">        Object[] arr2 = &#123;2, &quot;name2&quot;, &quot;password2&quot;&#125;;</span></span><br><span class="line"><span class="comment">        Object[] arr3 = &#123;3, &quot;name3&quot;, &quot;password3&quot;&#125;;</span></span><br><span class="line"><span class="comment">        userList.add(arr1);</span></span><br><span class="line"><span class="comment">        userList.add(arr2);</span></span><br><span class="line"><span class="comment">        userList.add(arr3);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">        <span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql, listArg);</span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//批量删除</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteBath</span><span class="params">(List&lt;Object[]&gt; listArg)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from user where id=?&quot;</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        List&lt;Object[]&gt; userList = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        Object[] arr1 = &#123;6&#125;;</span></span><br><span class="line"><span class="comment">        Object[] arr2 = &#123;7&#125;;</span></span><br><span class="line"><span class="comment">        userList.add(arr1);</span></span><br><span class="line"><span class="comment">        userList.add(arr2);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql, listArg);</span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><p> <strong>queryForObject</strong>  (sqlStr, 指定的数据类型, 参数列表)：查询一行任何类型的数据，最后一个参数指定返回结果类型。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="comment">//注入JdbcTemplate</span></span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from user&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">userCount</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, <span class="type">int</span>.class);  <span class="comment">//第二个参数是返回类型的class</span></span><br><span class="line">        <span class="keyword">return</span> userCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="comment">//注入JdbcTemplate</span></span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserInfo</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id=?&quot;</span>;</span><br><span class="line">        <span class="comment">// rowMapper 是一个接口，可以使用这个接口里面的实现类完成数据的封装，规定每一行记录和JavaBean的属性如何映射</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class), userId);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <strong>query</strong>  (sqlStr, RowMapper对象, 参数列表)：查询多行数据，并将结果集封装为元素是 JavaBean 的 list。（注意，指定的 JavaBean 的属性最好不要是基本类型，因为查询出来的结果可能是null，而null赋值为基本数据类型将会报错。比如int最好定义为Integer） </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="comment">//注入JdbcTemplate</span></span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getAllUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user&quot;</span>;</span><br><span class="line">        List&lt;User&gt; userList = jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class));</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
      <tags>
        <tag>SpringDataJdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>docker部署how2j项目实操</title>
    <url>/2022/07/12/docker%E9%83%A8%E7%BD%B2how2j%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%93%8D/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>本文档记录<a href="https://how2j.cn/k/deploy2linux/deploy2linux-autostart/1996.html">how2j的tmall项目</a>在本地虚拟机上使用docker生成镜像并推送到仓库的过程</p>
<p>Linux:centos7，docker为20.10…版本。<strong>注意有个坑，linux内核版本过低(比如内核版本3…和docker20…就不行)、docker版本过高，部署完也无法访问，<a href="https://blog.csdn.net/weixin_43604021/article/details/125722883">解决办法</a></strong></p>
<span id="more"></span>

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="拉取一个Linux镜像"><a href="#拉取一个Linux镜像" class="headerlink" title="拉取一个Linux镜像"></a>拉取一个Linux镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在自身虚拟机上的操作系统中拉取一个镜像</span><br><span class="line">docker pull centos:7.6.1810 </span><br></pre></td></tr></table></figure>

<h4 id="安装ftp服务"><a href="#安装ftp服务" class="headerlink" title="安装ftp服务"></a>安装ftp服务</h4><blockquote>
<p>为了后续从本地上传java应用、tomcat等到虚拟机中的操作系统方便，安装vsftpd</p>
</blockquote>
<h5 id="vsftpd介绍"><a href="#vsftpd介绍" class="headerlink" title="vsftpd介绍"></a>vsftpd介绍</h5><blockquote>
<p> vsftpd 全称是：very secure FTP daemon 非常安全的ftp后台程序，及ftp 服务端 </p>
</blockquote>
<h5 id="安装和启停"><a href="#安装和启停" class="headerlink" title="安装和启停"></a>安装和启停</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install vsftpd -y</span><br><span class="line">systemctl start vsftpd.service</span><br><span class="line">systemctl status vsftpd.service</span><br><span class="line">systemctl stop vsftpd.service</span><br><span class="line">//ftp服务启动的是21端口，使用如下命令应该观察到21端口正在处于监听状态，这也从侧面反应了ftp服务器启动成功了</span><br><span class="line">netstat -anp|grep 21</span><br></pre></td></tr></table></figure>

<h5 id="增加用户"><a href="#增加用户" class="headerlink" title="增加用户"></a>增加用户</h5><blockquote>
<p>为了连接上vsftpd，我们创建专门的用户</p>
<ul>
<li>创建一个目录专属于此用户拥有</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/wwwroot/ftptest</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建用户， 创建用户ftptest,并且指定其目录为用户目录中创建的/home/wwwroot/ftptest </p>
<ul>
<li><em>-g ftp 表示该用户属于ftp分组 (ftp分组是内置的，本来就存在，不需要自己创建)</em><br><em>-s /sbin/nologin 表示这个用户不能用来登录secureCRT这样的客户端。 这种不能登陆的用户又叫做虚拟用户</em><br> <em>创建过程给出的警告信息是正常的，不用理会</em></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd -d /home/wwwroot/ftptest -g ftp -s /sbin/nologin ftptest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>设置目录权限 ， 把目录/home/wwwroot/ftptest的拥有者设置为ftptest<br> 使ftptest用户拥有这个目录的读写权限 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R ftptest /home/wwwroot/ftptest</span><br><span class="line">chmod -R 775 /home/wwwroot/ftptest</span><br></pre></td></tr></table></figure>

<ul>
<li> 设置密码 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//输入 paw123###</span><br><span class="line">passwd ftptest</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="配置用户"><a href="#配置用户" class="headerlink" title="配置用户"></a>配置用户</h5><blockquote>
<ul>
<li>为了安全起见，去掉vsftpd的匿名登录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/vsftpd/vsftpd.conf</span><br><span class="line"></span><br><span class="line">//进入后把原来的anonymous_enable=YES改为</span><br><span class="line">anonymous_enable=NO</span><br></pre></td></tr></table></figure>

<ul>
<li>限制用户访问， 创建的ftptest用户所拥有的目录是 /home/wwwroot/ftptest,如果不做限制，那么使用ftptest登陆之后可以切换到其他敏感目录去，比如切换到/usr目录去，这样就存在巨大的安全隐患 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/vsftpd/vsftpd.conf</span><br><span class="line"></span><br><span class="line">//进入后找到</span><br><span class="line">#chroot_list_enable=YES</span><br><span class="line"># (default follows)</span><br><span class="line">#chroot_list_file=/etc/vsftpd/chroot_list</span><br><span class="line"></span><br><span class="line">//将这三行改为，即去掉注释</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line"># (default follows)</span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>添加用户名单</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/vsftpd/chroot_list</span><br><span class="line"></span><br><span class="line">//进入后增加一行</span><br><span class="line">ftptest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>打开写权限， vsftpd服务器是这样的，一旦某个用户被限制访问了，那么默认情况下，该用户的写权限也被剥夺了。 这就导致ftp客户端连接上服务器之后无法上传文件。 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/vsftpd/vsftpd.conf</span><br><span class="line">//最后面加上</span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="配置端口"><a href="#配置端口" class="headerlink" title="配置端口"></a>配置端口</h5><blockquote>
<p> vsftpd有两种端口，一个是21端口，用来监听客户端连接请求的。 这个一般说来是固定的，就一直使用21端口。<br> 另一种是，一旦获取到请求之后，再专门用户服务端和客户端传输数据的端口。<br> 本知识点就是用于指定第二种端口的获取范围 </p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/vsftpd/vsftpd.conf</span><br><span class="line"></span><br><span class="line">//进入后，在最后添加，这表示使用被动模式，用于传输数据的端口分配从30000-30010之间。</span><br><span class="line">pasv_enable=YES</span><br><span class="line">pasv_min_port=30000</span><br><span class="line">pasv_max_port=30010</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="鉴权配置"><a href="#鉴权配置" class="headerlink" title="鉴权配置"></a>鉴权配置</h5><blockquote>
<p>不懂为啥、、、跟着配置把</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/pam.d/vsftpd</span><br><span class="line">//注释掉/etc/pam.d/vsftpd文件里这一行：</span><br><span class="line">#auth required pam_shells.so</span><br><span class="line">//这样不去鉴权，从而允许 ftptest 这种 nologin用户登录 ftp 服务器.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart vsftpd.service</span><br><span class="line">systemctl status vsftpd.service</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h5><blockquote>
<p>有防火墙且开启的，需要开放端口，才能访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=21/tcp --permanent </span><br><span class="line">firewall-cmd --zone=public --add-port=30000-30010/tcp --permanent </span><br><span class="line">//开放完之后一定要刷新</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">//查看一下</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>本地下载个ftp客户端待后续使用，xftp、ftprush等等都行</p>
<h4 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h4><blockquote>
<p>这里的安装是在虚拟机中的docker容器里centos7安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//运行容器</span><br><span class="line">docker run -dit --privileged --name centos7 centos:7.6.1810  /usr/sbin/init</span><br><span class="line">//进入容器，补充：退出容器exit</span><br><span class="line">docker exec -it centos7 /bin/bash</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后再执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk.x86_64</span><br><span class="line">//验证</span><br><span class="line">java -version</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h4><blockquote>
<p>这里的安装是在虚拟机中的docker容器里centos7安装，进入容器同上</p>
<p>yum上mysql的资源有问题，所以不能仅仅之用yum。在使用yum之前还需要用其他命令获取mysql社区版 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm  </span><br><span class="line">rpm -ivh mysql-community-release-el7-5.noarch.rpm  </span><br><span class="line">//接着就可以通过yum安装了：</span><br><span class="line">yum install mysql mysql-server mysql-devel -y</span><br><span class="line"></span><br><span class="line">//启动</span><br><span class="line">systemctl start mysql.service</span><br><span class="line">//验证</span><br><span class="line">netstat -anp|grep 3306</span><br><span class="line"></span><br><span class="line">//设置mysql密码</span><br><span class="line">//通过Yum安装的mysql的管理员账户是没有密码的，这里通过命令设置其密码为 admin ，尽量使用这个密码哦，后续部署j2ee应用的时候会用到这个密码哦。</span><br><span class="line">mysqladmin -u root password admin</span><br><span class="line"></span><br><span class="line">//登录</span><br><span class="line">mysql -uroot -padmin</span><br><span class="line"></span><br><span class="line">//进入了终端，试试sql语句</span><br><span class="line">show databases;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h4><blockquote>
<p>yum上没有tomcat的源,可以用其他方式，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-7/v7.0.92/bin/apache-tomcat-7.0.92.tar.gz</span><br><span class="line">tar xzf apache-tomcat-7.0.92.tar.gz</span><br><span class="line">mv apache-tomcat-7.0.92 /usr/local/tomcat7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>但是本教程用的tomcat8，直接在这右上角<a href="https://how2j.cn/k/deploy2linux/deploy2linux-start/1611.html">下载</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//下载到本地，通过ftp客户端上传到虚拟机的操作系统，然后再通过docker的cp命令复制到容器centos7中</span><br><span class="line">//将宿主机目录线下/home/wwwroot/ftptest/apache-tomcat-8.5.23.tar.gz复制到名为centos7的容器的/tmp目录下面</span><br><span class="line">docker cp /home/wwwroot/ftptest/apache-tomcat-8.5.23.tar.gz centos7:/tmp</span><br><span class="line">//进入容器，同上</span><br><span class="line">...</span><br><span class="line">//解压、移动</span><br><span class="line">tar xzf apache-tomcat-8.5.23.tar.gz</span><br><span class="line">mv apache-tomcat-8.5.23 /usr/local/tomcat8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/12/docker%E9%83%A8%E7%BD%B2how2j%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%93%8D/gitee\Blog\source_posts\docker部署how2j项目实操\1657596789808.png" alt="1657596789808"></p>
<img src="/2022/07/12/docker%E9%83%A8%E7%BD%B2how2j%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%93%8D/1657596789808.png" class title="ftp客户端">

<ul>
<li>验证一下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//启动tomcat</span><br><span class="line">/usr/local/tomcat8/bin/startup.sh</span><br><span class="line">//查看端口</span><br><span class="line">netstat -anp|grep 8080</span><br><span class="line">//查看启动日志</span><br><span class="line">tail -300f /usr/local/tomcat8/logs/catalina.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>开放端口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent </span><br><span class="line">//开放完之后一定要刷新</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">//查看一下</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="部署java应用和sql语句"><a href="#部署java应用和sql语句" class="headerlink" title="部署java应用和sql语句"></a>部署java应用和sql语句</h4><p><a href="https://how2j.cn/k/deploy2linux/deploy2linux-upload/1614.html">rar包下载</a></p>
<blockquote>
<p> 下载tmall.rar，<strong>解压后上传</strong>到虚拟机的操作系统中，才通过docker的cp转移到容器中。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//步骤基本同上</span><br><span class="line">docker cp /home/wwwroot/ftptest/tmall centos7:/home/wwwroot/ftptest</span><br><span class="line">//最后的项目位置在/home/wwwroot/ftptest/tmall/web</span><br><span class="line">//配置tomcat</span><br><span class="line">vi /usr/local/tomcat7/conf/server.xml </span><br><span class="line">//然后在&lt;host下面增加一行</span><br><span class="line">&lt;Context path=&quot;/tmall&quot; docBase=&quot;/home/wwwroot/ftptest/tmall/web&quot; debug=&quot;0&quot; reloadable=&quot;false&quot; /&gt;</span><br><span class="line">//重启tomcat</span><br><span class="line">/usr/local/tomcat7/bin/shutdown.sh</span><br><span class="line">/usr/local/tomcat7/bin/startup.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <img src="/2022/07/12/docker%E9%83%A8%E7%BD%B2how2j%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%93%8D/gitee\Blog\source_posts\docker部署how2j项目实操\1657597958254.png" alt="1657597958254"></p>
 <img src="/2022/07/12/docker%E9%83%A8%E7%BD%B2how2j%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%93%8D/1657597958254.png" class title="tomcat配置应用">

<p> 下载tmall.sql，上传到虚拟机的操作系统中，才通过docker的cp转移到容器中。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Linux MySQL默认是大小写敏感的，但是模仿天猫在设计的时候是在windows上开发的，而windows上的Mysql默认是非大小写敏感的，所以JDBC代码有的表名是大写，有的是小写的，一旦运行起来就会因为大小写不一致导致无法识别表名。 为了解决这个矛盾，就需要把MySQL的大小写敏感修改为非敏感。解决办法如下：</span><br><span class="line">vi /etc/my.cnf</span><br><span class="line">//打开后在[mysqld]后添加添加</span><br><span class="line">lower_case_table_names=1</span><br><span class="line">//重启mysql</span><br><span class="line">systemctl restart mysqld.service</span><br><span class="line">//连接数据库</span><br><span class="line">mysql -uroot -padmin</span><br><span class="line">//创建数据库</span><br><span class="line">CREATE DATABASE tmall DEFAULT CHARACTER SET utf8;</span><br><span class="line">//查看</span><br><span class="line">show databases;</span><br><span class="line">//导入数据</span><br><span class="line">mysql -u root -padmin --default-character-set=utf8 tmall &lt; /home/wwwroot/ftptest/tmall.sql</span><br><span class="line">//重新登录验证</span><br><span class="line">mysql -uroot -padmin</span><br><span class="line">use tmall;</span><br><span class="line">show tables;</span><br><span class="line">select count(*) from product;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="设置自启动"><a href="#设置自启动" class="headerlink" title="设置自启动"></a>设置自启动</h4><h5 id="服务自启动"><a href="#服务自启动" class="headerlink" title="服务自启动"></a>服务自启动</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//分别执行如下代码就可以开启服务的自启动了。</span><br><span class="line">systemctl enable vsftpd.service</span><br><span class="line">systemctl enable mysqld.service</span><br><span class="line">//关闭</span><br><span class="line">systemctl disable vsftpd.service</span><br><span class="line">systemctl disable mysqld.service</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="脚本自启动"><a href="#脚本自启动" class="headerlink" title="脚本自启动"></a>脚本自启动</h5><p> 有个文件叫做 rc.local, 把脚本放进去就可以了。<br>不过这个脚本在 centos7里被降级了，不能被执行，所以要执行如下语句使得其可以被执行先 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x /etc/rc.d/rc.local</span><br><span class="line">//然后修改 /etc/rc.d/rc.local, 放入 tomcat脚本即可</span><br><span class="line">vi /etc/rc.d/rc.local</span><br><span class="line">/usr/local/tomcat7/bin/startup.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/12/docker%E9%83%A8%E7%BD%B2how2j%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%93%8D/gitee\Blog\source_posts\docker部署how2j项目实操\1657598168031.png" alt="1657598168031"></p>
<img src="/2022/07/12/docker%E9%83%A8%E7%BD%B2how2j%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%93%8D/1657598168031.png" class title="tomcat自启动">

<h4 id="容器打包成镜像"><a href="#容器打包成镜像" class="headerlink" title="容器打包成镜像"></a>容器打包成镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//容器打包成镜像</span><br><span class="line">docker commit -m=&quot;my tmall&quot; -a=&quot;yujin&quot; centos7 blknjyty/mytmall:v1</span><br><span class="line">//运行镜像</span><br><span class="line">docker run -dit --privileged -p80:80 -p8080:8080  --name mytmall blknjyty/mytmall:v1  /usr/sbin/init</span><br><span class="line">//本机访问</span><br><span class="line">http://虚拟机ip:8080/tmall/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/12/docker%E9%83%A8%E7%BD%B2how2j%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%93%8D/gitee\Blog\source_posts\docker部署how2j项目实操\1657598367247.png" alt="1657598367247"></p>
<img src="/2022/07/12/docker%E9%83%A8%E7%BD%B2how2j%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%93%8D/1657598367247.png" class title="项目启动图">

]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle</title>
    <url>/2022/07/07/gradle/</url>
    <content><![CDATA[<h2 id="Groovy简介"><a href="#Groovy简介" class="headerlink" title="Groovy简介"></a>Groovy简介</h2><p>整理自github仓库：<a href="https://github.com/kwf2030/gradle-tutorial">https://github.com/kwf2030/gradle-tutorial</a></p>
<p>为加强记忆和后续学习特此整理下来</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>基于JVM的的语言，Java家族中的一员,也是动态语言</p>
</blockquote>
<span id="more"></span>

<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote>
<ul>
<li>构建在Java语言之上，并结合了Python、Ruby、Smalltalk等语言的强大功能。</li>
<li>对Java开发者来说学习成本很低，无缝集成Java代码和类库。</li>
<li>既可用作面向对象语言，又可作为脚本语言使用。</li>
<li>引入了DSL（领域定义语言）概念，简单易读，方便维护。</li>
<li>支持函数式编程、运算符重载、闭包等特性。</li>
<li>可编译为Java字节码，在可运行Java的地方，就可运行Groovy。</li>
</ul>
</blockquote>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>as</td>
<td>简单粗暴的说就是类型强转（当然不仅仅是强转那么简单，目前只需要知道这个就够了），非常有用，到后面就知道了</td>
</tr>
<tr>
<td>def</td>
<td>变量定义（Groovy中使用def来定义一个变量，具体类型会在运行时进行类型推断，当然你也可以使用int, long等）</td>
</tr>
<tr>
<td>in</td>
<td>遍历集合之用，后面再说</td>
</tr>
</tbody></table>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p> Groovy中的数字在声明时可通过后缀的形式强制为其指定一个类型，例如： </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>后缀</th>
</tr>
</thead>
<tbody><tr>
<td>BigInteger</td>
<td>G/g</td>
</tr>
<tr>
<td>Long</td>
<td>L/l</td>
</tr>
<tr>
<td>Integer</td>
<td>I/i</td>
</tr>
<tr>
<td>BigDecimal</td>
<td>G/g</td>
</tr>
<tr>
<td>Double</td>
<td>D/d</td>
</tr>
<tr>
<td>Float</td>
<td>F/f</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：assert 43i == new Integer(&#x27;43&#x27;)</span><br></pre></td></tr></table></figure>

<h4 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="数字分隔符"></a>数字分隔符</h4><p>当一个数字位数很多的时候，大家应该都有用鼠标比对的经验吧。</p>
<p>为数字添加分隔符用于增强其可读性，数字本身不受影响，例如：<code>12_038_472_361_561</code>，数字一目了然，分隔符加在第几位是随意的，不一定非要3个一组。</p>
<h4 id="科学计数"><a href="#科学计数" class="headerlink" title="科学计数"></a>科学计数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assert 1e3  == 1_000.0</span><br><span class="line">assert 2E4  == 20_000.0</span><br><span class="line">assert 3E+1 == 30.0</span><br><span class="line">assert 4e-2 == 0.04</span><br></pre></td></tr></table></figure>

<h4 id="幂指数运算"><a href="#幂指数运算" class="headerlink" title="幂指数运算"></a>幂指数运算</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assert 2 ** 3 instanceof Integer</span><br><span class="line">assert 5L ** 3 instanceof Long</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="单引号字符串"><a href="#单引号字符串" class="headerlink" title="单引号字符串"></a>单引号字符串</h4><p><code>java.lang.String</code>的实例，支持转义，除了转义的字符外其它字符会原样输出，例如<code>&#39;Hello \&#39;Groovy\&#39;&#39;</code>。</p>
<h4 id="双引号字符串"><a href="#双引号字符串" class="headerlink" title="双引号字符串"></a>双引号字符串</h4><p>即所谓的<code>GString</code>，是<code>groovy.lang.GString</code>的实例，支持转义，可包含变量、表达式等（输出时会自动求值）</p>
<p>例如<code>&quot;Hello $groovy&quot;</code>，此处会去将groovy变量的值代入。</p>
<p>正如上面所说，另外一个比较有意思的是不仅支持变量，还支持表达式，例如<code>&quot;2+3=$&#123;2+3&#125;&quot;</code>会输出<code>2+3=5</code>。</p>
<p>更进一步，不仅是表达式，GString还支持语句，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;2+3=$&#123;def a = 2; def b = 3; a+b&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>如果只是单纯一个语句，没有任何返回值，该GString的计算结果就是<code>null</code>，所以最后一个语句应该返回一个值用来表示该次计算的结果（不用写<code>return</code>）。</p>
<p>尽管如此，请不要在GString中写过多过于复杂的语句，虽然看上去很NB的样子，最后也只会徒增烦恼。</p>
<p>GString还可以简写成$（不加大括号），不过仅适用于点号运算符前，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Hello $person.name&quot;</span><br></pre></td></tr></table></figure>

<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>即三个单引号或三个双引号的字符串，不用像Java那样每一行都以<code>\</code>连字符结尾或字符串相加，会原样输出，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"> Hello Groovy</span><br><span class="line">    你好，我是Groovy！</span><br><span class="line">    单独来一行</span><br><span class="line">原样输出, Haha~~</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="斜杠字符串"><a href="#斜杠字符串" class="headerlink" title="斜杠字符串"></a>斜杠字符串</h4><p>即被斜杠包围的字符串，例如：<code>&quot;/.*foo.*/&quot;</code>。</p>
<p>常用于正则表达式和模板，这些字符串本身没有必要转义（斜杠本身除外），所以，被斜杠包围的字符串除了斜杠本身的转义外，其他会被原样输出（不会被转义）。</p>
<p><em>注：如果斜杠之间是空的，会被视为单行注释，而不会被视为空字符串。</em></p>
<p>还有一种<code>$/</code>字符串因为用的比较少这里就不说了，有兴趣的可以自行搜索。</p>
<p>下面是一个字符串对照说明表</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>语法</th>
<th>支持表达式等</th>
<th>多行</th>
<th>转义符</th>
</tr>
</thead>
<tbody><tr>
<td>单引号字符串</td>
<td><code>&#39;...&#39;</code></td>
<td>不支持</td>
<td>不支持</td>
<td>\</td>
</tr>
<tr>
<td>三单引号字符串</td>
<td><code>&#39;&#39;&#39;...&#39;&#39;&#39;</code></td>
<td>不支持</td>
<td>支持</td>
<td>\</td>
</tr>
<tr>
<td>双引号字符串</td>
<td><code>&quot;...&quot;</code></td>
<td>支持</td>
<td>不支持</td>
<td>\</td>
</tr>
<tr>
<td>三双引号字符串</td>
<td><code>&quot;&quot;&quot;...&quot;&quot;&quot;</code></td>
<td>支持</td>
<td>支持</td>
<td>\</td>
</tr>
<tr>
<td>斜杠字符串</td>
<td><code>/.../</code></td>
<td>支持</td>
<td>支持</td>
<td>\</td>
</tr>
<tr>
<td>美元斜杠字符串</td>
<td><code>$/.../$</code></td>
<td>支持</td>
<td>支持</td>
<td>$</td>
</tr>
</tbody></table>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>Java8中正式开始支持闭包，语法与Groovy中的闭包不太一样，这里仅简单介绍一下Groovy中的闭包，闭包的强大之处远不止于此。</p>
<p>初看闭包，长的与Java（Java8之前）的匿名内部类极为相似，比如实现一个<code>Listener</code>接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在Java中</span><br><span class="line">add(new Listener() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void listen(Object obj) &#123;...&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//在Groovy的闭包中，这里用到了as关键字将闭包强转为Listener的实现</span><br><span class="line">def c = &#123; Object obj -&gt;</span><br><span class="line">	println obj</span><br><span class="line">&#125; as Listener</span><br><span class="line">add c</span><br></pre></td></tr></table></figure>

<p>就是这么简单，初学者还可以将闭包理解为可以传递的方法/函数，在Java中，方法/函数是不能传递的，现在Groovy中，我们就可以这么做了。上面的代码可以理解为给<code>add</code>方法传递了一个方法，在add方法体内调用执行这个传递的方法</p>
<p>闭包的形式为（<code>-&gt;</code>前面为闭包的参数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; Type1 param1, Type2 param2... -&gt;</span><br><span class="line">	//闭包代码...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个闭包与定义变量没区别</span><br><span class="line">def var = &#123; p -&gt;</span><br><span class="line">	println(p1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包的参数类型可以省略，当参数只有一个时，可以简写成<code>&#123;...&#125;</code>，唯一的参数用<code>it</code>表示（隐藏参数），调用闭包使用闭包的<code>call()</code>方法或者直接使用方法的调用形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//以下调用闭包的形式均是合法的</span><br><span class="line">var.call(5)</span><br><span class="line">var.call 8</span><br><span class="line">var(2)</span><br><span class="line">var 3</span><br><span class="line"></span><br><span class="line">//如果将一个闭包当作一个接口的实现，则调用时稍有不同</span><br><span class="line">//假设闭包var实现了上面的Listener接口，现在需要调用Listener接口的listen方法</span><br><span class="line">var.listen(obj)</span><br></pre></td></tr></table></figure>

<p>既然闭包可以作为参数传递，那么返回一个闭包也必然是可以的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def method() &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		println &quot;Hello World&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于闭包的几个隐含变量：</p>
<ul>
<li>it：上面已经说过了，如果一个闭包只有一个参数，可以省略，此时该参数的名字是<code>it</code></li>
<li>this：与Java中的this一致，定义该闭包的类的引用</li>
<li>owner：该层闭包的对象（如果闭包只有一层，则与this一致）</li>
<li>delegate：GroovyObject默认实现了代理设计模式，让代理来的更加方便，默认值是owner，但是可以随时改变代理对象。</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="List的定义"><a href="#List的定义" class="headerlink" title="List的定义"></a>List的定义</h5><p>Groovy自身没有定义任何List类型，所有的<code>List</code>都是<code>java.util.List</code>类型，在定义时，默认使用<code>ArrayList</code>实现，当然也可以指定类型（例如<code>LinkedList</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//List的定义类似Java的数组，放在中括号之间</span><br><span class="line">def list = [1,2,3,4]</span><br><span class="line"></span><br><span class="line">assert list instanceof List</span><br><span class="line">assert list.size() == 4</span><br><span class="line"></span><br><span class="line">//也可以在List中包含不同类型的值</span><br><span class="line">def list2 = [1, &quot;1&quot;, true]</span><br></pre></td></tr></table></figure>

<p>上面定义的<code>List</code>都是<code>ArrayList</code>类型，如果要使用其他类型，必须在声明时指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//下面两种都将list定义为LinkedList</span><br><span class="line">def list1 = [1,2,3] as LinkedList</span><br><span class="line">LinkedList list2 = [1,2,3]</span><br></pre></td></tr></table></figure>

<h5 id="List的操作"><a href="#List的操作" class="headerlink" title="List的操作"></a>List的操作</h5><p><code>List</code>的操作（读和写）可以通过类似数组下标的方式来实现，下标是正数为正向顺序（从零开始计数），下标是负数为反向顺序（从-1开始计数）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def list = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line">assert list[0] == &#x27;a&#x27;</span><br><span class="line">assert list[-1] == &#x27;d&#x27;</span><br><span class="line"></span><br><span class="line">//将第三个元素改为&#x27;X&#x27;</span><br><span class="line">list[2] = &#x27;X&#x27;</span><br><span class="line"></span><br><span class="line">//List的&lt;&lt;(左移运算符)已经重载，意思是向List的尾部添加一个元素，等同于List.add()</span><br><span class="line">list &lt;&lt; &#x27;Y&#x27;</span><br><span class="line">assert list[4] == &#x27;Y&#x27;</span><br><span class="line"></span><br><span class="line">//一次访问两个元素，返回一个List</span><br><span class="line">assert list[2,3] == [&#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line"></span><br><span class="line">//一次访问第一个到第三个元素，返回一个List</span><br><span class="line">assert list[0..2] == [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure>

<p><code>List</code>可嵌套，类似多维数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def list = [[1,2],[3,4]]</span><br><span class="line">assert list[1][0] == 3</span><br></pre></td></tr></table></figure>

<p><em>Groovy的<code>List</code>使用非常方便，其实为了方便理解，完全可以把<code>List</code>当成长度可扩展的数组。</em></p>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>在Groovy中，数组与<code>List</code>的格式是一样的，所以要使用数组形式，必须在定义时明确指类型或者强转（类似于使用非<code>ArrayList</code>的<code>List</code>类型）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] arr = [&#x27;AA&#x27;, &#x27;BB&#x27;, &#x27;CC&#x27;]</span><br><span class="line">assert arr instanceof String[]</span><br><span class="line"></span><br><span class="line">def num = [1, 2, 3] as int[]</span><br><span class="line">assert num instanceof int[]</span><br><span class="line"></span><br><span class="line">//多维数组</span><br><span class="line">Integer[][] matrix = [[1,2], [3,4]]</span><br><span class="line">assert matrix instanceof Integer[][]</span><br></pre></td></tr></table></figure>

<p>数组的访问与<code>List</code>完全一致，这里就不赘述了</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>Map</code>的语法类似于JSON数组，可使用两种形式访问/操作：</p>
<ul>
<li><code>map[key]</code> 类似数组的访问形式</li>
<li><code>map.key</code> 类似对象属性的访问形式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def colors = [red: &#x27;#FF0000&#x27;, green: &#x27;#00FF00&#x27;, blue: &#x27;#0000FF&#x27;]</span><br><span class="line">assert colors[&#x27;red&#x27;] == &#x27;#FF0000&#x27;</span><br><span class="line">assert colors.green = &#x27;#00FFFF&#x27;</span><br><span class="line"></span><br><span class="line">colors[&#x27;pink&#x27;] = &#x27;FF00FF&#x27;</span><br><span class="line">colors.yellow = &#x27;#FFFF00&#x27;</span><br><span class="line"></span><br><span class="line">//Groovy默认会使用`java.util.LinkedHashMap`来创建Map</span><br><span class="line">//要使用其他类型，请在声明时指定或使用强转</span><br><span class="line">assert colors instanceof java.util.LinkedHashMap</span><br></pre></td></tr></table></figure>

<p>如果访问一个不存在的key，则会返回null</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assert colors[&#x27;white&#x27;] == null</span><br></pre></td></tr></table></figure>

<p>上述的<code>colors</code>在创建时，虽然key没有用引号，但是Groovy会使用String作为key，这样就会产生一个问题 - 如果key中包含变量怎么办，会不会重复或导致语义混淆（怎么知道red是一个字符串而不是先前定义过的变量）？</p>
<p>Groovy可以使用其他类型来作为key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def map = [1:&#x27;hello&#x27;, 2:&#x27;world&#x27;]</span><br><span class="line">assert map[1] == &#x27;hello&#x27;</span><br></pre></td></tr></table></figure>

<p>数字不会导致语义混淆，因为它就是数字，不可能是变量，所以Groovy在创建上述Map时，就是用数字来作为key。</p>
<p><strong>除了数字之外，Groovy会将其他方式定义的key作为字符串存储，如果想要在key中使用变量，请使用小括号</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def key = &#x27;name&#x27;</span><br><span class="line"></span><br><span class="line">//此时map1中只有键名为&#x27;key&#x27;的映射，而不是&#x27;name&#x27;</span><br><span class="line">def map1 = [key: &#x27;Mike&#x27;]</span><br><span class="line">assert map1.contains(&#x27;name&#x27;)</span><br><span class="line"></span><br><span class="line">//此时map2中只有键名为&#x27;name&#x27;的映射，而不是&#x27;key&#x27;</span><br><span class="line">def map2 = [(key): &#x27;Mike&#x27;]</span><br><span class="line">assert map1.contains(&#x27;key&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><h3 id="做什么的"><a href="#做什么的" class="headerlink" title="做什么的"></a>做什么的</h3><ul>
<li>约定优于配置，但绝不强制约定</li>
<li>强大的依赖管理（基于Apache Ivy）</li>
<li>强大的多项目构建</li>
<li>完全兼容Ant和Maven/Ivy</li>
<li>Groovy构建脚本</li>
<li>语义化的脚本编写</li>
</ul>
<h3 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h3><ul>
<li>下载、解压、配置环境变量、配置本地仓库</li>
</ul>
<h3 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h3>]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>jooq使用</title>
    <url>/2022/07/15/jooq%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="JOOQ简介"><a href="#JOOQ简介" class="headerlink" title="JOOQ简介"></a>JOOQ简介</h3><blockquote>
<p><a href="https://jooq.org/">jOOQ</a>，是一个ORM框架，利用其生成的Java代码和流畅的API，可以快速构建有类型约束的安全的SQL语句 。 </p>
</blockquote>
<span id="more"></span>

<blockquote>
<p><strong>优点：</strong></p>
<ol>
<li><p>jOOQ的核心优势是可以将数据库表结构映射为Java类，包含表的基本描述和所有表字段。通过jOOQ提供的API，配合生成的Java代码，可以很方便的进行数据库操作 </p>
</li>
<li><p>生成的Java代码字段类型是根据数据库映射成的Java类型，在进行设置和查询操作时，因为是Java代码，都会有强类型校验，所以对于数据的输入，是天然安全的，极大的减少了SQL注入的风险 </p>
</li>
<li><p>jOOQ的代码生成策略是根据配置全量生成，任何对于数据库的改动，如果会影响到业务代码，在编译期间就会被发现，可以及时进行修复 </p>
</li>
</ol>
</blockquote>
<h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><blockquote>
<p>所有的操作jooq都提供两种方式， 第一种是使用 DSLContext API 以类SQL的语法进行调用，第二种是利用 Record API 进行调用 。这里面只记录第一种，了解第二种请点击<a href="https://jooq.diamondfsd.com/learn/section-2-base-curd.html">这里</a></p>
<p>了解：</p>
<ul>
<li><code>dslContext</code> 代表<code>DSLContext</code>实例</li>
<li><code>S1_USER</code> 由jOOQ插件生成的表描述常量</li>
<li><code>S1_USER.*</code> 由jOOQ插件生成的表内字段常量</li>
</ul>
<p>了解三个接口：</p>
<ul>
<li><code>org.jooq.Result</code> 结果集接口，此接口实现了List接口，可以当做一个集合来操作，是一个数据库查询结果集的包装类，除了集合的相关方法，该接口还提供了一些结果集转换，格式化，提取字段等方法。通常我们查询出来的结果都是此接口的实现类，掌握好此接口是jOOQ的基础接口，基本所有的SQL查询操作，都会碰到这个接口 </li>
<li><code>org.jooq.Record </code> 此接口再使用关系型数据库时，主要用于定义数据库表记录，储存的内容是一条表记录的字段和值，每个值会储存对应字段的类型，可以通过通用的 <code>getValue(Field field)</code> 方法，取到对应字段的值，也可以将这个接口看做是一条记录的字段/值映射 </li>
<li><code>org.jooq.DSLContext</code> jOOQ的核心接口之一，可以理解为一个SQL执行器，通过静态方法 <code>DSL.using</code>，可以获取一个 <code>DSLContext</code> 实例，此实例抽象了所有对于SQL的操作API，可以通过其提供的API方便的进行SQL操作  </li>
</ul>
</blockquote>
<h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类SQL语法 insertInto 方法第一个参数通常是表常量</span></span><br><span class="line">dslContext.insertInto(S1_USER, S1_USER.USERNAME, S1_USER.ADDRESS, S1_USER.EMAIL)</span><br><span class="line">        .values(<span class="string">&quot;username1&quot;</span>, <span class="string">&quot;demo-address1&quot;</span>, <span class="string">&quot;diamondfsd@gmail.com&quot;</span>)</span><br><span class="line">        .values(<span class="string">&quot;username2&quot;</span>, <span class="string">&quot;demo-address2&quot;</span>, <span class="string">&quot;diamondfsd@gmail.com&quot;</span>)</span><br><span class="line">        .execute();</span><br><span class="line"> <span class="comment">//批量插入</span></span><br><span class="line"> List&lt;S1UserRecord&gt; recordList = IntStream.range(<span class="number">0</span>, <span class="number">10</span>).mapToObj(i -&gt; &#123;</span><br><span class="line">    <span class="type">S1UserRecord</span> <span class="variable">s1UserRecord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">S1UserRecord</span>();</span><br><span class="line">    s1UserRecord.setUsername(<span class="string">&quot;usernameBatchInsert&quot;</span> + i);</span><br><span class="line">    s1UserRecord.setEmail(<span class="string">&quot;diamondfsd@gmail.com&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> s1UserRecord;</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br><span class="line">dslContext.batchInsert(recordList).execute();</span><br><span class="line"><span class="comment">//插入后获取主键</span></span><br><span class="line"><span class="comment">//通过此方法插入数据，可以通过 returning API读取想要返回的数据，此语法支持返回多个值，通过fetchOne()方法可以取到一个Record对象</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">userId</span> <span class="operator">=</span> dslContext.insertInto(S1_USER,</span><br><span class="line">    S1_USER.USERNAME, S1_USER.ADDRESS, S1_USER.EMAIL)</span><br><span class="line">    .values(<span class="string">&quot;username1&quot;</span>, <span class="string">&quot;demo-address1&quot;</span>, <span class="string">&quot;diamondfsd@gmail.com&quot;</span>)</span><br><span class="line">    .returning(S1_USER.ID)</span><br><span class="line">    .fetchOne().getId();</span><br><span class="line"><span class="comment">//插入时主键重复的处理办法</span></span><br><span class="line"><span class="comment">// 第一种 ：这里执行完，返回affecteRow影响行数为0，即不生效</span></span><br><span class="line"><span class="comment">// 生成的SQL: insert ignore into `learn-jooq`.`s1_user` (`id`, `username`) values (1, &#x27;username-1&#x27;)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">affecteRow</span> <span class="operator">=</span> dslContext.insertInto(S1_USER,</span><br><span class="line">    S1_USER.ID, S1_USER.USERNAME)</span><br><span class="line">    .values(<span class="number">1</span>, <span class="string">&quot;username-1&quot;</span>)</span><br><span class="line">    .onDuplicateKeyIgnore()</span><br><span class="line">    .execute();</span><br><span class="line"><span class="comment">// 第二种:更新主键所在列</span></span><br><span class="line"><span class="comment">//生成SQL: insert into `learn-jooq`.`s1_user` (`id`, `username`, `address`) values (1, &#x27;duplicateKey-update&#x27;, &#x27;hello world&#x27;) on duplicate key update `learn-jooq`.`s1_user`.`username` = &#x27;duplicateKey-update&#x27;, `learn-jooq`.`s1_user`.`address` = &#x27;update&#x27;</span></span><br><span class="line">dslContext.insertInto(S1_USER)</span><br><span class="line">    .set(S1_USER.ID, <span class="number">1</span>)</span><br><span class="line">    .set(S1_USER.USERNAME, <span class="string">&quot;duplicateKey-insert&quot;</span>)</span><br><span class="line">    .set(S1_USER.ADDRESS, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    .onDuplicateKeyUpdate()</span><br><span class="line">    .set(S1_USER.USERNAME, <span class="string">&quot;duplicateKey-update&quot;</span>)</span><br><span class="line">    .set(S1_USER.ADDRESS, <span class="string">&quot;update&quot;</span>)</span><br><span class="line">    .execute();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dslContext.update(S1_USER)</span><br><span class="line">    .set(S1_USER.USERNAME, <span class="string">&quot;apiUsername-1&quot;</span>)</span><br><span class="line">    .set(S1_USER.ADDRESS, <span class="string">&quot;update-address&quot;</span>)</span><br><span class="line">    .where(S1_USER.ID.eq(<span class="number">1</span>))</span><br><span class="line">    .execute()</span><br><span class="line">    </span><br><span class="line"><span class="comment">//批量更新</span></span><br><span class="line">  <span class="type">S1UserRecord</span> <span class="variable">record1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">S1UserRecord</span>();</span><br><span class="line">record1.setId(<span class="number">1</span>);</span><br><span class="line">record1.setUsername(<span class="string">&quot;batchUsername-1&quot;</span>);</span><br><span class="line"><span class="type">S1UserRecord</span> <span class="variable">record2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">S1UserRecord</span>();</span><br><span class="line">record2.setId(<span class="number">2</span>);</span><br><span class="line">record2.setUsername(<span class="string">&quot;batchUsername-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">List&lt;S1UserRecord&gt; userRecordList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">userRecordList.add(record1);</span><br><span class="line">userRecordList.add(record2);</span><br><span class="line">dslContext.batchUpdate(userRecordList).execute();</span><br></pre></td></tr></table></figure>

<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><blockquote>
<p> 基本查询方法，默认查询指定表的所有字段，返回一个结果集的包装，通过<code>Result.into</code>方法，可以将结果集转换为任意指定类型集合，当然也可以通过 <code>Record.getValue</code> 方法取得任意字段值，值类型依赖于字段类型 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// select `learn-jooq`.`s1_user`.`id`, `learn-jooq`.`s1_user`.`username`, `learn-jooq`.`s1_user`.`email`, `learn-jooq`.`s1_user`.`address`, `learn-jooq`.`s1_user`.`create_time`, `learn-jooq`.`s1_user`.`update_time` from `learn-jooq`.`s1_user`</span></span><br><span class="line">Result&lt;Record&gt; fetchResult = dslContext.select().from(S1_USER).fetch();</span><br><span class="line">List&lt;S1UserRecord&gt; result = fetch.into(S1UserRecord.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// select `learn-jooq`.`s1_user`.`id`, `learn-jooq`.`s1_user`.`username`, `learn-jooq`.`s1_user`.`email`, `learn-jooq`.`s1_user`.`address`, `learn-jooq`.`s1_user`.`create_time`, `learn-jooq`.`s1_user`.`update_time` from `learn-jooq`.`s1_user` where `learn-jooq`.`s1_user`.`id` in (1, 2)</span></span><br><span class="line">Result&lt;Record&gt; fetchAll = dslContext.select().from(S1_USER)</span><br><span class="line">                .where(S1_USER.ID.in(<span class="number">1</span>, <span class="number">2</span>)).fetch();</span><br><span class="line">fetchAll.forEach(record -&gt; &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> record.getValue(S1_USER.ID);</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> record.getValue(S1_USER.USERNAME);</span><br><span class="line">    <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> record.getValue(S1_USER.ADDRESS);</span><br><span class="line">    <span class="type">Timestamp</span> <span class="variable">createTime</span> <span class="operator">=</span> record.getValue(S1_USER.CREATE_TIME);</span><br><span class="line">    <span class="type">Timestamp</span> <span class="variable">updateTime</span> <span class="operator">=</span> record.getValue(S1_USER.UPDATE_TIME);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>jooq也支持关联查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserMessagePojo为新建的Pojo类，用于存储查询结果，可以忽略具体内容</span></span><br><span class="line">Result&lt;Record3&lt;String, String, String&gt;&gt; record3Result =</span><br><span class="line">        dslContext.select(S1_USER.USERNAME,</span><br><span class="line">        S2_USER_MESSAGE.MESSAGE_TITLE,</span><br><span class="line">        S2_USER_MESSAGE.MESSAGE_CONTENT)</span><br><span class="line">        .from(S2_USER_MESSAGE)</span><br><span class="line">        .leftJoin(S1_USER).on(S1_USER.ID.eq(S2_USER_MESSAGE.USER_ID))</span><br><span class="line">        .fetch();</span><br><span class="line">List&lt;UserMessagePojo&gt; userMessagePojoList = record3Result.into(UserMessagePojo.class)</span><br></pre></td></tr></table></figure>

<p><strong>Condition动态查询</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query</span><span class="params">(String name,String age)</span> &#123;</span><br><span class="line">		Condition condition=DSL.trueCondition();<span class="comment">//真实条件</span></span><br><span class="line">		<span class="keyword">if</span>(name!=<span class="literal">null</span>) &#123;</span><br><span class="line">			condition=condition.and(Tables.STUDENT.NAME.eq(name));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(age!=<span class="literal">null</span>) &#123;</span><br><span class="line">			condition=condition.and(Tables.STUDENT.AGE.eq(Integer.parseInt(age)));</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;Student&gt; list=context.select().from(Tables.STUDENT).where(condition).fetch().into(Student.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dslContext.delete(S1_USER).where(S1_USER.USERNAME.eq(<span class="string">&quot;demo1&quot;</span>)).execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量删除</span></span><br><span class="line"><span class="type">S1UserRecord</span> <span class="variable">record1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">S1UserRecord</span>();</span><br><span class="line">record1.setId(<span class="number">1</span>);</span><br><span class="line"><span class="type">S1UserRecord</span> <span class="variable">record2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">S1UserRecord</span>();</span><br><span class="line">record2.setId(<span class="number">2</span>);</span><br><span class="line">dslContext.batchDelete(record1, record2).execute();</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">List&lt;S1UserRecord&gt; recordList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">recordList.add(record1);</span><br><span class="line">recordList.add(record2);</span><br><span class="line">dslContext.batchDelete(recordList).execute();</span><br></pre></td></tr></table></figure>

<h3 id="结果处理"><a href="#结果处理" class="headerlink" title="结果处理"></a>结果处理</h3><blockquote>
<p>查询操作通常以fetch API 作为结束API，例如常用的有，所有的读取类方法都差不多，掌握一个就能很快的举一反三</p>
<ul>
<li>读取多条<ul>
<li><code>fetch</code> 读取集合</li>
<li><code>fetchSet</code> 读取并返回一个Set集合，常用于去重</li>
<li><code>fetchArray</code> 读取并返回一个数组</li>
</ul>
</li>
<li>读取单条<ul>
<li><code>fetchOne</code> 读取单条记录，如果记录超过一条会报错</li>
<li><code>fetchAny</code> 读取单条记录，如果有多条，会取第一条数据</li>
<li><code>fetchSingle</code> 读取单条记录，如果记录为空或者记录超过一条会报错</li>
</ul>
</li>
<li>读取并返回Map<ul>
<li><code>fetchMap</code> 读取并返回一个Map</li>
<li><code>fetchGroups</code> 读取并返回一个分组Map</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h4><ul>
<li><p><code>fetch()</code><br>无参调用此方法，返回的是一个<code>Result</code>结果集对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Result&lt;Record&gt; records = dslContext.select().from(S1_USER).fetch();</span><br></pre></td></tr></table></figure></li>
<li><p><code>fetch(RecordMapper mapper)</code><br><code>RecordMapper</code>接口的提供<code>map</code>方法，用于来返回数据。<code>map</code> 方法传入一个 <code>Record</code> 对象。可以使用lambda表达式将 <code>Record</code> 对象转换成一个指定类型的POJO</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;S1UserPojo&gt; userPojoList = dslContext.select()</span><br><span class="line">            .from(S1_USER)</span><br><span class="line">            .where(S1_USER.ID.eq(<span class="number">1</span>))</span><br><span class="line">            .fetch(r -&gt; r.into(S1UserPojo.class));</span><br></pre></td></tr></table></figure>

<p>多表查询，字段相同时，直接用into方法将结果集转换为POJO时，相同字段名称的方法会以最后一个字段值为准。这时候，我们可以现将结果集通过 <code>into(Table table)</code> 方法将结果集转换为指定表的<code>Record</code>对象，然后再<code>into</code>进指定的POJO类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多表关联查询，查询s2_user_message.id = 2的数据，直接into的结果getId()却是1</span></span><br><span class="line"><span class="comment">// 这是因为同时关联查询了s1_user表，该表的id字段值为1</span></span><br><span class="line">List&lt;S2UserMessage&gt; userMessage = dslContext.select().from(S2_USER_MESSAGE)</span><br><span class="line">        .leftJoin(S1_USER).on(S1_USER.ID.eq(S2_USER_MESSAGE.USER_ID))</span><br><span class="line">        .where(S2_USER_MESSAGE.ID.eq(<span class="number">2</span>))</span><br><span class="line">        .fetch(r -&gt; r.into(S2UserMessage.class));</span><br><span class="line"><span class="comment">// userMessage.getId() == 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结果集into进指定的表描述中，然后在into至指定的POJO类</span></span><br><span class="line">List&lt;S2UserMessage&gt; userMessage2 = dslContext.select().from(S2_USER_MESSAGE)</span><br><span class="line">        .leftJoin(S1_USER).on(S1_USER.ID.eq(S2_USER_MESSAGE.USER_ID))</span><br><span class="line">        .where(S2_USER_MESSAGE.ID.eq(<span class="number">2</span>))</span><br><span class="line">        .fetch(r -&gt; &#123;</span><br><span class="line">            <span class="type">S2UserMessage</span> <span class="variable">fetchUserMessage</span> <span class="operator">=</span> r.into(S2_USER_MESSAGE).into(S2UserMessage.class);</span><br><span class="line">            fetchUserMessage.setUsername(r.get(S1_USER.USERNAME));</span><br><span class="line">            <span class="keyword">return</span> fetchUserMessage;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// userMessage.getId() == 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>fetch(Field field)</code><br><code>Field</code>是一个接口，代码生成器生成的表字段常量例如 <code>S1_USER.ID</code>, 都实现了 <code>Field</code> 接口，这个重载可以直接取出指定表字段，会自动根据传入的字段推测其类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; id = dslContext.select().from(S1_USER).where(S1_USER.ID.eq(<span class="number">1</span>))</span><br><span class="line">        .fetch(S1_USER.ID);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>fetch(String fieldName, Class type)</code><br>可以直接通过字段名称字符串获取指定字段值，可以通过第二个参数指定返回值，如果不指定，返回Object</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; idList = dslContext.select().from(S1_USER).where(S1_USER.ID.eq(<span class="number">1</span>))</span><br><span class="line">        .fetch(<span class="string">&quot;id&quot;</span>, Integer.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>fetch(int fieldIndex, Class type)</code><br>可以通过查询字段下标顺序进行查询指定字段，可以通过第二个参数指定返回值，如果不指定，返回Object</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; idList = dslContext.select(S1_USER.ID, S1_USER.USERNAME)</span><br><span class="line">        .from(S1_USER).where(S1_USER.ID.eq(<span class="number">1</span>)).fetch(<span class="number">0</span>, Integer.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="fetch-1"><a href="#fetch-1" class="headerlink" title="fetch"></a>fetch</h4><p>此方法可以将结果集处理为一个Map格式，此方法有很多重载，这里介绍几个常用的，注意，此方法作为key的字段必须确定是在当前结果集中是唯一的，如果出现重复key，此方法会抛出异常</p>
<ul>
<li><p><code>fetchMap(Field field, Class type)</code><br>以表字段值为key，返回一个 <code>K:V</code> 的Map对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, S1UserPojo&gt; idUserPojoMap = dslContext.select().from(S1_USER)</span><br><span class="line">                .fetchMap(S1_USER.ID, S1UserPojo.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>fetchMap(Feild field, Field field)</code><br>以表字段值为key，返回一个 <code>K:V</code> 的Map对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; idUserNameMap = dslContext.select().from(S1_USER)</span><br><span class="line">                .fetchMap(S1_USER.ID, S1_USER.USERNAME);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="fetchgroup"><a href="#fetchgroup" class="headerlink" title="fetchgroup"></a>fetchgroup</h4><p>此方法可以将结果集处理为一个Map格式，和<code>fetchMap</code>类似，只不过这里的值为一个指定类型的集合，通常在处理一对多数据时会用到</p>
<ul>
<li><p><code>fetchGroups(Field field, Class type)</code><br>以表字段值为Key，返回一个<code>K:List</code> 的Map对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;S2UserMessage&gt;&gt; userIdUserMessageMap = dslContext.select().from(S2_USER_MESSAGE)</span><br><span class="line">                .fetchGroups(S2_USER_MESSAGE.USER_ID, S2UserMessage.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>fetchGroups(Field keyField, Field valueField)</code></p>
</li>
<li><p>以表字段值为Key，返回一个K:List<V>的Map对象</V></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;Integer&gt;&gt; userIdUserMessageIdMap = dslContext.select().from(S2_USER_MESSAGE)</span><br><span class="line">                .fetchGroups(S2_USER_MESSAGE.USER_ID, S2_USER_MESSAGE.ID);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://jooq.diamondfsd.com/learn/section-1-how-to-start.html">参考JOOQ中文文档教程</a></p>
<p><a href="https://blog.csdn.net/qq_39940674/article/details/93383177">更多用法参考</a></p>
]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
      <tags>
        <tag>jooq</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s</title>
    <url>/2022/07/05/k8s/</url>
    <content><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><h4 id="1-1-什么是-Kubernetes"><a href="#1-1-什么是-Kubernetes" class="headerlink" title="1.1 什么是 Kubernetes"></a>1.1 什么是 <strong>Kubernetes</strong></h4> <span id="more"></span> 

<blockquote>
<p>我们只到Docker应用容器引擎，使得服务的创建、销毁、移植等变得十分快捷、方便。Kubernate可以理解为管理、编排容器的工具，管理多个应用(集群规模)的创建、部署、服务、扩容缩容、更新等等。就是类似于Docker-compose的功能。</p>
<p>   除集群规模管理外，k8s可以更快的更新新版本，打包应用，更新的时候可以做到不用中断服务，服务器故障不用停机，从开发环境到测试环境到生产环境的迁移极其方便，一个配置文件搞定，一次生成image，到处运行 </p>
</blockquote>
<h4 id="1-2-Kubernetes-在哪些地方使用"><a href="#1-2-Kubernetes-在哪些地方使用" class="headerlink" title="1.2  Kubernetes 在哪些地方使用"></a>1.2  <strong>Kubernetes</strong> 在哪些地方使用</h4><p>我们在企业生产过程中能够的使用步骤一般是：</p>
<ul>
<li><p>创建集群：master管理、监控，node打工人</p>
</li>
<li><p>部署应用：通过k8s的方式(默认容器是docker),即在yaml文件中指定容器镜像等配置</p>
</li>
<li><p>发布应用：部署完应用后必须发布才能被外部访问，因为此时的ip地址只有同一个集群才能访问</p>
</li>
<li><p>扩展应用：比如遇上双11等活动对机器进行扩容，过后再进行缩容。</p>
</li>
<li><p>更新应用：有新版本了，滚动更新，根据新的image创建一个pod，分配各种资源，然后自动负载均衡，删除老的pod，然后继续更新，不会中断服务； 更新错了怎么办，不会影响生产业务，回滚就好了</p>
</li>
</ul>
<h4 id="1-3-master"><a href="#1-3-master" class="headerlink" title="1.3 master"></a>1.3 master</h4><blockquote>
<p>Kubernetes 可以管理大规模的集群，使集群中的每一个节点彼此连接，能够像控制一台单一的计算机一样控制整个集群。</p>
<p> <strong>master</strong> 是集群的”大脑”，负责管理整个集群：像应用的调度、更新、扩缩容等。</p>
</blockquote>
<p>master上包含组件：</p>
<ul>
<li> <strong>kube-apiserver</strong> : 集群入口，所有操作都经过此</li>
<li> <strong>kube-controller-manager</strong> ：所有资源的控制中心</li>
<li> <strong>kube-scheduler</strong> ：具体负责资源调度的进程</li>
</ul>
<h4 id="1-4-node"><a href="#1-4-node" class="headerlink" title="1.4 node"></a>1.4 node</h4><blockquote>
<p>就是具体”干活”的，一个Node一般是一个虚拟机或物理机，它上面事先运行着 docker 服务和 kubelet 服务（ Kubernetes 的一个组件），当接收到 master 下发的”任务”后，Node 就要去完成任务（用docker 运行一个指定的应用）</p>
</blockquote>
<p>node上包含的组件：</p>
<ul>
<li> <strong>kubelet</strong> ：node上的Agent，负责pod对应容器的创建、启停等，听master指挥干活并随时汇报。</li>
<li> <strong>kube-proxy</strong> ： 在Node节点上实现Pod网络代理，实现Kubernetes Service的通信和负载均衡机制的重要组件。 </li>
<li> <strong>docker</strong> ： Docker引擎，负责本机的容器的创建和管理工作 </li>
</ul>
<h4 id="1-5-Etcd"><a href="#1-5-Etcd" class="headerlink" title="1.5 Etcd"></a>1.5 Etcd</h4><blockquote>
<p>Etcd是Kubernetes提供默认的键值存储系统，保存所有集群数据，使用时需要为Etcd数据提供备份计划 </p>
</blockquote>
<p><img src="/2022/07/05/k8s/gitee\Blog\source_posts\k8s\1657022314159.png" alt="1657022314159"></p>
<img src="/2022/07/05/k8s/1657022314159.png" class title="Kubernetes网络架构图">

<h4 id="1-6-对象"><a href="#1-6-对象" class="headerlink" title="1.6 对象"></a>1.6 对象</h4><h5 id="1-6-1-Pod"><a href="#1-6-1-Pod" class="headerlink" title="1.6.1 Pod"></a>1.6.1 Pod</h5><blockquote>
<p>集群调度的最小单元，Pod 是一组容器（当然也可以只有一个）。容器本身就是一个小盒子了，Pod 相当于在容器上又包了一层小盒子。所以Pod里的容器有如下特点：</p>
<ul>
<li>可以直接通过 volume 共享存储。</li>
<li>有相同的网络空间，通俗点说就是有一样的ip地址，有一样的网卡和网络设置。</li>
<li>多个容器之间可以“了解”对方，比如知道其他人的镜像，知道别人定义的端口等。</li>
</ul>
</blockquote>
<h5 id="1-6-2-Service"><a href="#1-6-2-Service" class="headerlink" title="1.6.2 Service"></a>1.6.2 Service</h5><blockquote>
<p>即服务发现，不管Deployment的Pod有多少个，不管它是更新、销毁还是重建，Service总是能发现并维护好它的ip列表。</p>
<p>Service通过标签Label，知道其负责了哪几个Pod。这样就更加灵活，使其和Deployment解耦开来</p>
</blockquote>
<h5 id="1-6-3-Volume"><a href="#1-6-3-Volume" class="headerlink" title="1.6.3 Volume"></a>1.6.3 Volume</h5><blockquote>
<p> Volume(存储卷)Volume是Pod中能够被多个容器共享的磁盘目录。 </p>
<p>Kubernetes提供了非常丰富的Volume类型:</p>
<ul>
<li>emptyDir：临时空间，Pod分配到Node时创建，无须指定宿主主机上对应的目录，在Kubernetes会自动分配当前Node的一个目录，当Pod被移除时，emptyDir中的数据也会永久删除。</li>
<li>hostPath：为Pod挂载宿主主机上的文件或目录。用于数据永久保存。在不同的Node上具有相同配置的Pod,可能会因为宿主机上的目录和文件不同而导致Volume上的目录和文件的访问结果不一致。</li>
<li>gcePersistentDisk：使用谷歌公有云提供的永久磁盘。数据永久保存。</li>
<li>NFS：NFS 是 Network File System 的缩写，即网络文件系统。Kubernetes 中通过简单地配置就可以挂载 NFS 到 Pod 中，而 NFS 中的数据是可以永久保存的，同时 NFS 支持同时写操作。</li>
</ul>
</blockquote>
<h5 id="1-6-4-Namespace"><a href="#1-6-4-Namespace" class="headerlink" title="1.6.4 Namespace"></a>1.6.4 Namespace</h5><blockquote>
<p> 命名空间，Namespace在很多情况下用于实现多租户的资源隔离。Namespace通过集群内部的资源对象”分配”到不同的Namespace中，形成逻辑上分组的不同项目，便于不同的分组共享使用整个集群的资源的同时还能被分别管理。 </p>
</blockquote>
<h5 id="1-6-5-Deployment"><a href="#1-6-5-Deployment" class="headerlink" title="1.6.5 Deployment"></a>1.6.5 Deployment</h5><blockquote>
<p> 通过Kubernetes的 <strong>Deployment</strong> 的配置文件去描述应用，比如应用叫什么名字、使用的镜像名字、要运行几个实例、需要多少的内存资源、cpu 资源等等。即应用管理者，是用于部署应用的对象。<strong>不会单独创建一个pod资源对象，而是创建Deployment对象，通过Deployment来管理pod。</strong> </p>
</blockquote>
<h5 id="1-6-6-ReplicaSet"><a href="#1-6-6-ReplicaSet" class="headerlink" title="1.6.6 ReplicaSet"></a>1.6.6 ReplicaSet</h5><blockquote>
<p> ReplicaSet 实现了 Pod 的多副本管理。使用 Deployment 时会自动创建 ReplicaSet，也就是说 Deployment 是通过 ReplicaSet 来管理 Pod 的多个副本，所以我们通常不需要直接使用 ReplicaSet。 </p>
</blockquote>
<h3 id="2-项目部署"><a href="#2-项目部署" class="headerlink" title="2.项目部署"></a>2.项目部署</h3><p><img src="/2022/07/05/k8s/gitee\Blog\source_posts\k8s\20210111140539700.png" alt="20210111140539700"></p>
<img src="/2022/07/05/k8s/20210111140539700.png" class title="k8s架构图">

<blockquote>
<ul>
<li><p>服务器上有Docker和相关镜像的前提下</p>
</li>
<li><p>创建Deployment的YAML描述文件，根据yaml文件创建服务和集群</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create deployment countgame --image=192.168.137.110:5000/countgame:0.91 --dry-run -o yaml  &gt; deploy.yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># pod的最基础的yaml文件最少需要以下的几个参数</span><br><span class="line">apiVersion: v1 # API版本号，注意：具有多个，不同的对象可能会使用不同API</span><br><span class="line">kind: Pod  # 对象类型，pod</span><br><span class="line">metadata:  # 元数据</span><br><span class="line">name: string # POD名称</span><br><span class="line">namespace: string # 所属的命名空间</span><br><span class="line">spec: # specification of the resource content(资源内容的规范)</span><br><span class="line">containers: # 容器列表</span><br><span class="line">      - name: string # 容器名称</span><br><span class="line">image: string # 容器镜像</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/05/k8s/gitee\Blog\source_posts\k8s\2021011113290971.png" alt="2021011113290971"></p>
<img src="/2022/07/05/k8s/2021011113290971.png" class title="deployment配置文件">

<ul>
<li><p>创建Deployment对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply -f deploy.yaml </span><br></pre></td></tr></table></figure></li>
<li><p>创建了Deployment对象再查看pod</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2022/07/05/k8s/gitee\Blog\source_posts\k8s\20210111143610186.png" alt="20210111143610186"></p>
<p>​      <img src="/2022/07/05/k8s/20210111143610186.png" class title="一个pod图"></p>
<p>​         x修改 spec.replicas为3之后再查看，就有三个pod。</p>
<ul>
<li><p>查看pod启动日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl logs +pod的name</span><br></pre></td></tr></table></figure></li>
</ul>
<p>此时集群内部已经可以访问项目了。··············</p>
<ul>
<li><p>使集群对外部提供服务，创建service关联，对外暴露ip提供服务</p>
<blockquote>
<p>运行pod ip是docker网桥的IP地址段进行分配的，通常是一个虚拟的二层网络，外部网络并没有办法访问，并且，pod ip是随时会变的，不是固定的，k8s引入了Service的概念，通过Service管理这些pod，Service创建后的Service IP是固定的。但是Service IP(Cluster IP)是一个虚拟的IP,由Kubernetes管理和分配P地址，外部网络无法访问。k8s有三种方式暴露Service给外部网络访问。</p>
<p><img src="/2022/07/05/k8s/gitee\Blog\source_posts\k8s\20210111163501631.png" alt="20210111163501631"></p>
<img src="/2022/07/05/k8s/20210111163501631.png" class title="pod的ip"></blockquote>
</li>
</ul>
</blockquote>
<h3 id="3-Serivce暴露ip方式"><a href="#3-Serivce暴露ip方式" class="headerlink" title="3.Serivce暴露ip方式"></a>3.Serivce暴露ip方式</h3><h4 id="3-1-NodePort"><a href="#3-1-NodePort" class="headerlink" title="3.1 NodePort"></a>3.1 NodePort</h4><blockquote>
<p> 在k8s上可以给Service设置成NodePort类型，这样的话可以让Kubernetes在其所有节点上开放一个端口给外部访问（所有节点上都使用相同的端口号）， 并将传入的连接转发给作为Service服务对象的pod。这样我们的pod就可以被外部请求访问到 </p>
</blockquote>
<p><img src="/2022/07/05/k8s/gitee\Blog\source_posts\k8s\20210111203759964.png" alt="20210111203759964"></p>
<img src="/2022/07/05/k8s/20210111203759964.png" class title="NodePort方式">

<ul>
<li><p>创建serivice的yaml文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment countgame --port=8082 --target-port=8082 --type=NodePort -o yaml --dry-run &gt; svc.yaml</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p>1.countgame 为指定的service对象名称<br>2.- -port 是指service暴露在cluster ip上的端口，通过<cluster ip>:port 访问集群内部service的入口<br>3.- -target-port指 对应pod容器里面监听的端口<br>4.- -type=NodePort ， <nodeIP>:nodePort 是提供给集群外部客户访问service的入口<br>5.–dry-run表示测试不在k8s运行（不会具体执行该命令）<br>6.-o yaml 生成yaml格式<br>7.最后面的 “&gt; deploy.yaml” 表示将生成yaml内容输出到deploy.yaml文件</nodeIP></cluster></p>
<p><strong>配置文件内容基本如下：</strong></p>
<p><img src="/2022/07/05/k8s/gitee\Blog\source_posts\k8s\2021011117261340-1657085291453.png" alt="2021011117261340"></p>
<img src="/2022/07/05/k8s/2021011117261340-1657085291453.png" class title="service配置文件内容"></li>
<li><p>创建Service对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建service</span><br><span class="line">kubectl apply -f svc.yaml</span><br><span class="line">#查看service</span><br><span class="line">kubectl get svc</span><br><span class="line">#查看service关联的pod</span><br><span class="line">kubectl describe svc coutgame</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/05/k8s/gitee\Blog\source_posts\k8s\20210111172704176.png" alt="20210111172704176"></p>
<img src="/2022/07/05/k8s/20210111172704176.png" class title="创建并查看">

<p><img src="/2022/07/05/k8s/gitee\Blog\source_posts\k8s\20210111200610224.png" alt="20210111200610224"></p>
<img src="/2022/07/05/k8s/20210111200610224.png" class title="查看"></li>
<li><p> 可以看到service名称为countgame的service的对外端口为11413，会把通过这个端口访问的请求转发到service对象关联的pod对象的8082端口上 。访问192.168.137.110：11413/countgame/user/toGame可以访问项目</p>
</li>
<li><p><strong>缺点： 服务一旦多起来，NodePort 在每个节点上开启的端口会及其庞大，而且难以维护，所以生产环境不建议这么使用</strong> </p>
</li>
</ul>
<h4 id="3-2-LoadBalane"><a href="#3-2-LoadBalane" class="headerlink" title="3.2 LoadBalane"></a>3.2 LoadBalane</h4><blockquote>
<p>LoadBalane是上面通过NodePort暴露外部访问的一个优化，增加了一个负载均衡器，上面的NodePort是所有节点都开放一个端口，直接给外部访问，并没有Node节点的负载均衡。LoadBalane则是在上面的基础上增加了一层，只提供一个公网ip给外部访问，外部访问这个ip再负载均衡分发给Node节点的Pod</p>
</blockquote>
<p><img src="/2022/07/05/k8s/gitee\Blog\source_posts\k8s\2021011120562767.png" alt="2021011120562767"></p>
<img src="/2022/07/05/k8s/2021011120562767.png" class title="LoadBalane">

<p>部署起来和上述NodePort界面差不多。kind参数变为LoadBalane</p>
<ul>
<li>缺点： 每一个用 LoadBalancer 暴露的服务都会有它自己的 IP 地址和端口，不能做到一个ip地址就可以访问所有服务。 </li>
</ul>
<h4 id="3-3-Ingress"><a href="#3-3-Ingress" class="headerlink" title="3.3 Ingress"></a>3.3 Ingress</h4><blockquote>
<p>采用 NodePort 方式暴露服务面临问题是，服务一旦多起来，NodePort 在每个节点上开启的端口会及其庞大，而且难以维护；如果采用LoadBalane，每个服务都得开放一个公网IP，也会很庞大。这时候Ingress暴露服务就是一种很合适的方案。可以通过一个Ingress暴露多个服务。</p>
</blockquote>
<p><img src="/2022/07/05/k8s/gitee\Blog\source_posts\k8s\2021011121501187.png" alt="2021011121501187"></p>
<img src="/2022/07/05/k8s/2021011121501187.png" class title="LoadBalane">

<p>参考：<a href="https://blog.csdn.net/qq_21187515/article/details/112359593?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165700886516782425182493%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165700886516782425182493&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-112359593-null-null.142%5Ev30%5Epc_search_v2,185%5Ev2%5Econtrol&utm_term=k8s&spm=1018.2226.3001.4187">博文1</a></p>
<p><a href="https://blog.csdn.net/TM6zNf87MDG7Bo/article/details/79621510?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165700886516782425182493%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165700886516782425182493&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-79621510-null-null.142%5Ev30%5Epc_search_v2,185%5Ev2%5Econtrol&utm_term=k8s&spm=1018.2226.3001.4187">博文2</a></p>
<p><a href="http://www.imooc.com/article/285913?block_id=tuijian_wz">博文3</a></p>
]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2022/07/06/maven/</url>
    <content><![CDATA[<h5 id="解决问题："><a href="#解决问题：" class="headerlink" title="解决问题："></a>解决问题：</h5><blockquote>
<p>1.jar包依赖2.jar依赖传递3.jar版本冲突4.项目生命周期</p>
</blockquote>
<span id="more"></span>

<h5 id="文件解析："><a href="#文件解析：" class="headerlink" title="文件解析："></a>文件解析：</h5><p><img src="/2022/07/06/maven/gitee\TechnologyStack\images\1625198265(1).jpg" alt="1625198265(D:\gitee\Blog\source\_posts\maven\1625198265(1).jpg)"><img src="/2022/07/06/maven/1625198265(1).jpg" class title="maven目录"></p>
<h5 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h5><p>1.找mvn可执行文件—bin下面的运行脚本</p>
<p>2.找配置文件 conf/setting.xml ,优先找目录优先级：~/.m2 &gt; M2_HOME/conf</p>
<p>3.本地仓库寻找插件clean，没有则去远程仓库下载</p>
<p>4.运行插件</p>
<h5 id="标签详解："><a href="#标签详解：" class="headerlink" title="标签详解："></a>标签详解：</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>项目包名<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>项目唯一标识<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--打包类型：jar/war/pom--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--父级文件用pm：install时不会生成jar或者war包</span></span><br><span class="line"><span class="comment">	主要作用：1.可以通过&lt;modules&gt;标签来整合子模块的编译顺序（Maven引入依赖使用最短路径原则，例如a&lt;–b&lt;–c1.0 ，d&lt;–e&lt;–f&lt;–c1.1，由于路径最短，最终引入的为c1.0；但路径长度相同时，则会引入先申明的依赖）。因此尽量将更加底层的service放在更先的位置优先加载依赖较为合适。</span></span><br><span class="line"><span class="comment">2.可以将一些子项目中共用的依赖或将其版本统一写到父级配置中，以便统一管理。</span></span><br><span class="line"><span class="comment">3.groupId, artifactId, version能直接从父级继承，减少子项目的pom配置。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--需要部署用war：编译后的.class文件按层级结构形成文件树后打包形成的压缩包。它会将项目中依赖的所有jar包都放在WEB-INF/lib这个文件夹下--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--内部调用用jar：当我们使用mvn install命令的时候，能够发现在项目中与src文件夹同级新生成了一个target文件夹，这个文件夹内的classes文件夹即为刚才提到的编译后形成的文件夹--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>打包类型<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 </span></span><br><span class="line"><span class="comment">            目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact </span></span><br><span class="line"><span class="comment">        ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         	<span class="comment">&lt;!--依赖的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， </span></span><br><span class="line"><span class="comment">                尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath </span></span><br><span class="line"><span class="comment">                - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 </span></span><br><span class="line"><span class="comment">                - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--构建项目所需要的信息--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用的插件列表 。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--plugin元素包含描述插件所需要的信息。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的group ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--被使用的插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--execution元素包含了插件执行需要的信息 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置是否被传播到子POM --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            ......</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h5><p>分为本地和远程两个仓库</p>
<p>本地：~/.m2/settings.xml  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>本地仓库地址<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>远程：在配置文件中找到repositories和mirror，设置远程仓库和镜像。</p>
<p>mirror相当于一个拦截器，它会拦截maven对remote repository的相关请求，把请求里的remote repository地址，重定向到mirror里配置的地址。</p>
<h5 id="mvn构建生命周期："><a href="#mvn构建生命周期：" class="headerlink" title="mvn构建生命周期："></a>mvn构建生命周期：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">:valid：验证项目;</span><br><span class="line">:compile：执行编译;</span><br><span class="line">:test:使用合适的框架进行测试;</span><br><span class="line">:package：创建jar/war包;</span><br><span class="line">:verify:对继承测试的结果进行检查;</span><br><span class="line">:install：打包到本地仓库，供其他项目使用;</span><br><span class="line">:depoly：拷贝到远程仓库;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>为了完成 default 生命周期，这些阶段（包括其他未在上面罗列的生命周期阶段）将被按顺序地执行。</p>
<p>Maven 有以下三个标准的生命周期：</p>
<ul>
<li><strong>clean</strong>：项目清理的处理</li>
<li>**default(或 build)**：项目部署的处理</li>
<li><strong>site</strong>：项目站点文档创建的处理</li>
</ul>
<p>常用命令和生命周期的关系：</p>
<p><em>注：当一个阶段通过 Maven 命令调用时，例如 mvn compile，只有该阶段之前以及包括该阶段在内的所有阶段会被执行。</em></p>
<p> mvn clean: 移除上一下次构建生成的文件（具体涉及clean生命周期，有兴趣可以自己查查）</p>
<p>mvn clean install :执行clean，然后再从头valid一直到install</p>
<p>clean install -DskipTests：跳过测试执行clean install</p>
]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客创建教程</title>
    <url>/2022/04/15/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/102592286">参考文章链接</a></p>
<h3 id="1-新建github-安装Git并且绑定账号"><a href="#1-新建github-安装Git并且绑定账号" class="headerlink" title="1.新建github,安装Git并且绑定账号"></a>1.新建github,安装Git并且绑定账号</h3><h3 id="2-安装nodejs"><a href="#2-安装nodejs" class="headerlink" title="2.安装nodejs"></a>2.安装nodejs</h3><ul>
<li><p>安装完成后，用 node -v 和 npm -v 命令检查</p>
</li>
<li><p>设置nodejs全局变量的安装路径和环境变量</p>
 <span id="more"></span> 

<blockquote>
<ul>
<li><p>在 nodejs 文件夹中新建两个空文件夹 node_cache、node_global ;</p>
</li>
<li><p>打开cmd，输入如下两个命令：</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;D:\nodejs\node_global&quot;</span><br><span class="line">npm config set cache &quot;D:\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>环境变量配置： <strong>win10系统 –&gt; 打开控制面板 –&gt; 系统 –&gt;高级系统设置 –&gt; 环境变量</strong> </li>
<li> 然后在系统变量中新建一个变量名为“NODE_PATH”，值为“…\nodejs\node_global\node_modules”</li>
<li> 然后编辑用户变量里的Path，将相应npm的路径改为：”…\nodejs\node_global”</li>
<li> 检查：在 cmd 命令下执行 npm install webpack -g 。检查…\nodejs\node_global\node_modules里是否有webpack包</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h3><ul>
<li><p>新建Blog文件夹，用git bush 在该目录下输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li>
<li><p> 安装完成后，输入 hexo init 命令初始化博客， 然后输入 hexo g 静态部署， 这时网页已经部署完成，输入 hexo s 命令可以 浏览器输入 <a href="http://localhost:4000/">http://localhost:4000</a>  查看。</p>
</li>
</ul>
<h3 id="4-Hexo部署到github"><a href="#4-Hexo部署到github" class="headerlink" title="4.Hexo部署到github"></a>4.Hexo部署到github</h3><ul>
<li> Blog 文件夹，用笔记本打开 _config.yml 文件 (<font color="red">注意后边的空格，例type: git</font>)</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/fengye97/fengye97.github.io.git  #你的仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<ul>
<li> 然后回到 Blog 文件夹中，打开 Git Bash，安装Git部署插件，输入命令： </li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<ul>
<li><p>三步走.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure></li>
<li><p> 打开浏览器，输入 <a href="https://xxx.github.io/">https://xxx.github.io</a> 就可以打开你的网页了 </p>
</li>
</ul>
<h3 id="5-装饰博客"><a href="#5-装饰博客" class="headerlink" title="5.装饰博客"></a>5.装饰博客</h3><h4 id="5-1-下载一个好看的主题"><a href="#5-1-下载一个好看的主题" class="headerlink" title="5.1 下载一个好看的主题"></a>5.1 下载一个好看的主题</h4><p>例如下载next主题，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>此时在Blog/themes下就有next主题文件夹。</p>
<p>在根目录 _config.yml(称为<strong>站点配置文件</strong>)，修改主题（<strong>注意冒号后都要有空格</strong>） </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title:  #标题</span><br><span class="line">subtitle: &#x27;&#x27;</span><br><span class="line">description:  #简介或者格言</span><br><span class="line">keywords:</span><br><span class="line">author:#作者</span><br><span class="line">language: zh-CN  #主题语言</span><br><span class="line">timezone: Asia/Shanghai  #中国的时区</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next   #主题改为next</span><br></pre></td></tr></table></figure>

<p>next主题也可以进一步配置： next主题有四种，如下图依次为Muse、Mist、Pisces、Gemini 。 打开目录Blog/themes/next/下的_config.yml（称为<strong>主题配置文件</strong>），只要将你选的主题前的#删除就行了： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini    #这是我选的主题</span><br></pre></td></tr></table></figure>

<p>最后就可以三步走hexo clean , hexo g, hexo d 部署到gtihub上即可(本地可以先调试看看 hexo s，访问 <a href="http://localhost:4000看看，没问题再部署">http://localhost:4000看看，没问题再部署</a>)</p>
<h4 id="5-2-配置菜单"><a href="#5-2-配置菜单" class="headerlink" title="5.2 配置菜单"></a>5.2 配置菜单</h4><p> 打开主题配置文件即themes/next下的_config.yml，查找menu，将前面的#删除就行了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home                      #首页</span><br><span class="line">  archives: /archives/ || archive      #归档</span><br><span class="line">  categories: /categories/ || th       #分类</span><br><span class="line">  tags: /tags/ || tags                 #标签</span><br><span class="line">  about: /about/ || user               #关于</span><br><span class="line">  resources: /resources/ || download   #资源</span><br><span class="line">  #schedule: /schedule/ || calendar    #日历</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap    #站点地图，供搜索引擎爬取</span><br><span class="line">  #commonweal: /404/ || heartbeat      #腾讯公益404</span><br></pre></td></tr></table></figure>

<p>“||”前面的是目标链接，后面的是图标名称，next使用的图标全是<a href="https://link.zhihu.com/?target=http://www.fontawesome.com.cn/faicons/%23web-application">图标库 - Font Awesome 中文网</a>这一网站的，有想用的图标直接在fontawesome上面找图标的名称就行。resources是我自己添加的。</p>
<p> 新添加的菜单需要翻译对应的中文，打开theme/next/languages/zh-CN.yml，在menu下设置： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">	resources: 资源</span><br></pre></td></tr></table></figure>

<p>在根目录下 打开Git Bash，输入如下代码： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;about&quot;</span><br><span class="line">hexo new page &quot;resources&quot;</span><br></pre></td></tr></table></figure>

<p> 此时在根目录的sources文件夹下会生成categories、tags、about、resources四个文件，每个文件中有一个<code>index.md</code>文件，修改内容分别如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 关于</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;about&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 资源</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;resources&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p> 注：如果有启用评论，默认页面带有评论。需要关闭的话，添加字段comments并将值设置为false。 </p>
<h4 id="5-3-图片显示问题"><a href="#5-3-图片显示问题" class="headerlink" title="5.3 图片显示问题"></a>5.3 图片显示问题</h4><p>在站点配置文件中设置：post_asset_folder: true，此时当我们hexo n 创建博客时，会创建同名文件夹存放博客中的图片等各种资源。在博客中使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img image.jpg 这是一张图片 %&#125;</span><br></pre></td></tr></table></figure>

<p>引用图片即可</p>
<h3 id="6-写博客"><a href="#6-写博客" class="headerlink" title="6.写博客"></a>6.写博客</h3><p>Blog主目录下hexo n “博客名”，即可创建要书写的博客。</p>
<p>在上面的属性编辑栏中设置一些标签，分类之类的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 个人博客创建教程</span><br><span class="line">date: 2022-04-15 10:07:03</span><br><span class="line">tags: 教程</span><br><span class="line">categories: 教程</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2022/07/01/Docker/</url>
    <content><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><h4 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1 什么是Docker"></a>1.1 什么是Docker</h4><blockquote>
<p>Docker是开源的应用容器引擎，或者说是一种容器标准。<strong>开发者可以使用其将自身的应用、依赖包、开发环境等打包到一个轻量级、可移植的容器中。</strong> 打包之后可以发布到Linux等系统上，具有开销小、启动快等优点。</p>
</blockquote>
 <span id="more"></span> 

<h4 id="1-2-Docker应用场景有哪些"><a href="#1-2-Docker应用场景有哪些" class="headerlink" title="1.2 Docker应用场景有哪些"></a>1.2 Docker应用场景有哪些</h4><ul>
<li>Web 应用的自动化打包和发布</li>
<li>自动化测试和持续集成、发布</li>
<li> 在服务型环境中部署和调整数据库或其他的后台应用 </li>
</ul>
<h4 id="1-3-Docker和虚拟机的区别"><a href="#1-3-Docker和虚拟机的区别" class="headerlink" title="1.3 Docker和虚拟机的区别"></a>1.3 Docker和虚拟机的区别</h4><p><img src="/2022/07/01/Docker/gitee\Blog\source_posts\Docker\1656937545326.png" alt="1656937545326"></p>
<img src="/2022/07/01/Docker/1656937545326.png" class title="虚拟机结构图">

<p><img src="/2022/07/01/Docker/gitee\Blog\source_posts\Docker\1656937564921.png" alt="1656937564921"></p>
<img src="/2022/07/01/Docker/1656937564921.png" class title="Docker结构图">

<blockquote>
<p>从上图可以看出，虚拟机和Docker的底层都是基础硬件设施，倒数第二层虚拟机是管理系统(进行资源的隔离、分配等)、而Docker的倒数第二层是操作系统。**这就是最主要的区别，Docker是虚拟OS(复用OS)，而虚拟机是虚拟硬件(复用硬件)**。</p>
<p>故Docker的优缺点也显而易见了：</p>
<ul>
<li>由于其<strong>复用OS</strong>，所以如果有容器把内核搞挂了，那么宿主内核也会挂掉。</li>
<li>由于其少了虚拟机管理的两层，故其创建开销小、速度快，使得应用程序和基础架构分开，达到快速迭代和交付软件的目的。简而言之，**1.<strong>快速一致的交付应用程序</strong>2.**使项目可移植性更高，更轻量级 **</li>
</ul>
</blockquote>
<h4 id="1-4-Docker的组成"><a href="#1-4-Docker的组成" class="headerlink" title="1.4 Docker的组成"></a>1.4 Docker的组成</h4><p><img src="/2022/07/01/Docker/gitee\Blog\source_posts\Docker\1384642-20191227100415937-2126100108.png" alt="1384642-20191227100415937-2126100108"></p>
<img src="/2022/07/01/Docker/1384642-20191227100415937-2126100108.png" class title="Docker的构成">

<blockquote>
<p>上图囊括了Docker的基本常用操作，同时也可以看出Docker的组成部分：镜像(images)、容器(Containers)、客户端、主机、Docker仓库。</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>镜像(Images)</td>
<td>基于联合文件系统的一种层次式结构，由一系列指令构建出来，是从最底层到最高层依次修改的最终结果，不同镜像可以共享层。</td>
</tr>
<tr>
<td>容器(Containers)</td>
<td>独立运行的一个或一组应用，基于镜像创建。<strong>镜像就相当于类，容器相当于对象。</strong></td>
</tr>
<tr>
<td>客户端</td>
<td>客户端通过命令行或其他工具使用Docker API和Docker的守护进程通信。</td>
</tr>
<tr>
<td>守护进程</td>
<td>Docker服务端进行，负责支撑容器运行和镜像管理</td>
</tr>
<tr>
<td>主机</td>
<td>物理或者虚拟机器(用于执行守护进程和容器)</td>
</tr>
<tr>
<td>仓库</td>
<td>类似于github，镜像管理平台</td>
</tr>
</tbody></table>
<h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><p><a href="https://www.runoob.com/docker/centos-docker-install.html">可参考官方文档或者菜鸟教程均可</a></p>
<p>以CentOS为例，安装步骤分为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#yum包更新到最新</span><br><span class="line">sudo yum update</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#卸载旧版本docker和相关依赖</span><br><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。</span><br><span class="line">#先安装所需软件包</span><br><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#设置稳定的仓库：官方源、阿里云等等</span><br><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">#或者</span><br><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#安装最新版本的 Docker Engine-Community</span><br><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#安装完成后，启动Docker </span><br><span class="line">$ sudo systemctl start docker </span><br><span class="line">#查看版本</span><br><span class="line">$ sudo docker version</span><br><span class="line">#停止docker服务</span><br><span class="line">$ sudo systemctl stop docker</span><br><span class="line">#重启docker服务</span><br><span class="line">$ sudo systemctl restart docker</span><br><span class="line">#查看服务状态</span><br><span class="line">$ sudo  systemctl status docker</span><br><span class="line">#设置开机启动</span><br><span class="line">$ sudo  systemctl enable docker</span><br></pre></td></tr></table></figure>

<h3 id="3-镜像"><a href="#3-镜像" class="headerlink" title="3.镜像"></a>3.镜像</h3><blockquote>
<p>概念理解：镜像就相当于我们设置好运行环境、所需软件的这么一个包，简单的说就是一个应用。</p>
<p>具体解释：比如开发人员可以从docker仓库拉取（下载）一个只包含centos7系统的基础镜像，然后在这个镜像中安装jdk、mysql、Tomcat和自己开发的应用，最后将这些环境打一个新的镜像。开发人员将这个新的镜像提交给测试人员进行测试，测试人员只需要在测试环境下运行这个镜像就可以了，这样就可以保证开发人员的环境和测试人员的环境完全一致。</p>
<p><strong>有镜像了我们才能基于其创建容器。</strong></p>
</blockquote>
<h4 id="3-1-查看镜像-本地主机上的镜像"><a href="#3-1-查看镜像-本地主机上的镜像" class="headerlink" title="3.1 查看镜像(本地主机上的镜像)"></a>3.1 查看镜像(本地主机上的镜像)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/01/Docker/gitee\Blog\source_posts\Docker\1656985651701.png" alt="1656985651701"></p>
<img src="/2022/07/01/Docker/1656985651701.png" class title="Docker查看镜像">

<ul>
<li><strong>REPOSITORY：</strong>表示镜像的仓库源</li>
<li><strong>TAG：</strong>镜像的标签</li>
<li><strong>IMAGE ID：</strong>镜像ID</li>
<li><strong>CREATED：</strong>镜像创建时间</li>
<li><strong>SIZE：</strong>镜像大小</li>
</ul>
<h4 id="3-2-拉取镜像"><a href="#3-2-拉取镜像" class="headerlink" title="3.2 拉取镜像"></a>3.2 拉取镜像</h4><blockquote>
<p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:13.10</span><br></pre></td></tr></table></figure>

<h4 id="3-3-删除镜像"><a href="#3-3-删除镜像" class="headerlink" title="3.3 删除镜像"></a>3.3 删除镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi ubuntu:13.10</span><br></pre></td></tr></table></figure>

<h4 id="3-4-搜索镜像"><a href="#3-4-搜索镜像" class="headerlink" title="3.4 搜索镜像"></a>3.4 搜索镜像</h4><blockquote>
<p> 我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search httpd</span><br></pre></td></tr></table></figure>

<h4 id="3-5-创建镜像"><a href="#3-5-创建镜像" class="headerlink" title="3.5 创建镜像"></a>3.5 创建镜像</h4><blockquote>
<p>创建镜像有两种选择：</p>
<ul>
<li> 从已经创建的容器中更新镜像，并且提交这个镜像 </li>
<li> 使用 Dockerfile 指令来创建一个新的镜像 </li>
</ul>
</blockquote>
<h5 id="3-5-1-根据容器更新"><a href="#3-5-1-根据容器更新" class="headerlink" title="3.5.1 根据容器更新"></a><strong>3.5.1</strong> 根据容器更新</h5><p>对于第一种，我们需要先根据原镜像创建一个容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -t -i ubuntu:15.10 /bin/bash</span><br><span class="line">root@e218edb10161:/# </span><br></pre></td></tr></table></figure>

<p>在运行的容器内使用 <strong>apt-get update</strong> 命令进行更新。</p>
<p>在完成操作之后，输入 <strong>exit</strong> 命令来退出这个容器。</p>
<p>此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 <strong>docker commit</strong> 来提交容器副本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</span><br><span class="line">sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>-m:</strong> 提交的描述信息</li>
<li><strong>-a:</strong> 指定镜像作者</li>
<li><strong>e218edb10161：</strong>容器 ID</li>
<li><strong>runoob/ubuntu:v2:</strong> 指定要创建的目标镜像名:标签</li>
</ul>
<h5 id="3-5-2-Dockerfile创建新的镜像"><a href="#3-5-2-Dockerfile创建新的镜像" class="headerlink" title="3.5.2 Dockerfile创建新的镜像"></a>3.5.2 Dockerfile创建新的镜像</h5><p> 我们需要创建一个 <strong>Dockerfile 文件</strong>，其中包含一组指令来告诉 Docker 如何构建我们的镜像。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ cat Dockerfile </span><br><span class="line">FROM    centos:6.7</span><br><span class="line">MAINTAINER      Fisher &quot;fisher@sudops.com&quot;</span><br><span class="line"></span><br><span class="line">RUN     /bin/echo &#x27;root:123456&#x27; |chpasswd</span><br><span class="line">RUN     useradd runoob</span><br><span class="line">RUN     /bin/echo &#x27;runoob:123456&#x27; |chpasswd</span><br><span class="line">RUN     /bin/echo -e &quot;LANG=\&quot;en_US.UTF-8\&quot;&quot; &gt;/etc/default/local</span><br><span class="line">EXPOSE  22</span><br><span class="line">EXPOSE  80</span><br><span class="line">CMD     /usr/sbin/sshd -D</span><br></pre></td></tr></table></figure>

<p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</p>
<p>第一条FROM，指定使用哪个镜像源</p>
<p>RUN 指令告诉docker 在镜像内执行命令，安装了什么。</p>
<p> 我们使用 Dockerfile 文件，通过 <strong>docker build</strong> 命令来构建一个镜像 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker build -t runoob/centos:6.7 .</span><br><span class="line">Sending build context to Docker daemon 17.92 kB</span><br><span class="line">Step 1 : FROM centos:6.7</span><br><span class="line"> ---&amp;gt; d95b5ca17cc3</span><br><span class="line">Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot;</span><br><span class="line"> ---&amp;gt; Using cache</span><br><span class="line"> ---&amp;gt; 0c92299c6f03</span><br><span class="line">Step 3 : RUN /bin/echo &#x27;root:123456&#x27; |chpasswd</span><br><span class="line"> ---&amp;gt; Using cache</span><br><span class="line"> ---&amp;gt; 0397ce2fbd0a</span><br><span class="line">Step 4 : RUN useradd runoob</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>-t</strong> ：指定要创建的目标镜像名</li>
<li><strong>.</strong> ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</li>
</ul>
<h4 id="3-6-设置镜像标签"><a href="#3-6-设置镜像标签" class="headerlink" title="3.6 设置镜像标签"></a>3.6 设置镜像标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker tag 860c279d2fec runoob/centos:dev</span><br></pre></td></tr></table></figure>

<p> docker tag 镜像ID，这里是 860c279d2fec ,镜像源名(repository name)和新的标签名(tag)。 </p>
<h3 id="4-容器"><a href="#4-容器" class="headerlink" title="4.容器"></a>4.容器</h3><blockquote>
<p>容器就是基于镜像(类)生成的具体对象</p>
</blockquote>
<p>故生成容器之前，本地得有相应的镜像。</p>
<h4 id="4-1-生成容器"><a href="#4-1-生成容器" class="headerlink" title="4.1 生成容器"></a>4.1 生成容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#若无镜像则先拉取</span><br><span class="line">docker pull ubuntu</span><br><span class="line">#根据镜像生成容器</span><br><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>此时终端进入如下界面，表示进行容器内部的终端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@0123ce188bd8:/#</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>-i</strong>: 允许和容器进行交互式操作。</li>
<li><strong>-t</strong>: 在新的容器内指定一个伪终端</li>
<li><strong>ubuntu</strong>: ubuntu 镜像。</li>
<li><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li>
</ul>
<p>在容器终端输入exit退出，不指定名称docker会自动命名，当然我们也可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --name myubuntu ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="4-2-查看所有容器"><a href="#4-2-查看所有容器" class="headerlink" title="4.2 查看所有容器"></a>4.2 查看所有容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dockers ps -a</span><br></pre></td></tr></table></figure>

<h4 id="4-3-启停容器"><a href="#4-3-启停容器" class="headerlink" title="4.3 启停容器"></a>4.3 启停容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker start 容器id</span><br><span class="line">docker restart 容器id</span><br><span class="line">docker stop 容器id</span><br></pre></td></tr></table></figure>

<h4 id="4-4-后台运行"><a href="#4-4-后台运行" class="headerlink" title="4.4 后台运行"></a>4.4 后台运行</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd --name ubuntu-test ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p> 我们希望 docker 的服务是在后台运行的，我们可以过 <strong>-d</strong> 指定容器的运行模式。 加了 <strong>-d</strong> 参数默认不会进入容器，想要进入容器需要使用指令 <strong>docker exec</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 243c32535da7 /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="4-5-导入导出容器"><a href="#4-5-导入导出容器" class="headerlink" title="4.5 导入导出容器"></a>4.5 导入导出容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#到处容器快照到本地</span><br><span class="line">docker export 容器id&gt;ubuntu.tar</span><br><span class="line">#可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:</span><br><span class="line">cat docker/ubuntu.tar | docker import - test/ubuntu:v1</span><br><span class="line">#此外，也可以通过指定 URL 或者某个目录来导入</span><br><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>

<h4 id="4-6-删除容器"><a href="#4-6-删除容器" class="headerlink" title="4.6 删除容器"></a>4.6 删除容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm -f 1e560fca3906</span><br></pre></td></tr></table></figure>

<h4 id="4-7-具体例子"><a href="#4-7-具体例子" class="headerlink" title="4.7 具体例子"></a>4.7 具体例子</h4><p>运行一个 web 应用</p>
<p>前面我们运行的容器并没有一些什么特别的用处。</p>
<p>接下来让我们尝试使用 docker 构建一个 web 应用程序。</p>
<p>我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull training/webapp</span><br><span class="line">docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure>

<p>参数说明:</p>
<ul>
<li>**-d:**让容器在后台运行。</li>
<li>**-P:**将容器内部使用的网络端口随机映射到我们使用的主机上。</li>
</ul>
<p>此时 使用 <strong>docker ps</strong> 来查看我们正在运行的容器： </p>
<p><img src="/2022/07/01/Docker/gitee\Blog\source_posts\Docker\1656989652436.png" alt="1656989652436"></p>
<img src="/2022/07/01/Docker/1656989652436.png" class title="运行容器">

<p>可以看到， Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上。 </p>
<p>访问192.168.239.130:32769即可访问到web应用。</p>
<p><strong>改变运行端口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000：5000 training/webapp python app.py</span><br></pre></td></tr></table></figure>

<p>当然我们也可以通过指定容器绑定的网络地址，比如绑定127.0.0.1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure>

<p>此时就可以通过127.0.0.1：5000来访问容器的5000端口</p>
<h4 id="4-8-容器日志"><a href="#4-8-容器日志" class="headerlink" title="4.8 容器日志"></a>4.8 容器日志</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs -f bf08b7f2cd89</span><br></pre></td></tr></table></figure>

<p> <strong>-f:</strong> 让 <strong>docker logs</strong> 像使用 <strong>tail -f</strong> 一样来输出容器内部的标准输出。 </p>
<h4 id="4-9-查看容器内部进程"><a href="#4-9-查看容器内部进程" class="headerlink" title="4.9 查看容器内部进程"></a>4.9 查看容器内部进程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker top 容器名或者id</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/01/Docker/gitee\Blog\source_posts\Docker\1656990335923.png" alt="1656990335923"></p>
<img src="/2022/07/01/Docker/1656990335923.png" class title="运行容器">

<h4 id="4-10-查看某个容器底层信息"><a href="#4-10-查看某个容器底层信息" class="headerlink" title="4.10 查看某个容器底层信息"></a>4.10 查看某个容器底层信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect 容器名或者id</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/01/Docker/gitee\Blog\source_posts\Docker\1656990480994.png" alt="1656990480994"></p>
<img src="/2022/07/01/Docker/1656990335923.png" class title="运行容器">

<h4 id="4-11-容器互联"><a href="#4-11-容器互联" class="headerlink" title="4.11 容器互联"></a>4.11 容器互联</h4><p>运行容器并且新建test-net网络，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -itd --name test1 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p> 打开新的终端，再运行一个容器并加入到 test-net 网络: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -itd --name test2 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>在容器test1内部ping test2,可以ping通，同理反过来也可以i。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it test1 /bin/bash</span><br><span class="line">root@432432fd231e3f:/# ping test2</span><br></pre></td></tr></table></figure>

<h4 id="4-12-文件拷贝"><a href="#4-12-文件拷贝" class="headerlink" title="4.12 文件拷贝"></a>4.12 文件拷贝</h4><ul>
<li><p>从宿主机拷贝到容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker cp 需要拷贝的文件或目录 容器名称:容器目录</span><br><span class="line"># 创建一个文件abc.txt</span><br><span class="line">touch abc.txt</span><br><span class="line"># 复制abc.txt到mycentos2的容器的 / 目录下</span><br><span class="line">docker cp abc.txt mycentos2:/</span><br><span class="line"># 进入mycentos2容器</span><br><span class="line">docker exec -it mycentos2 /bin/bash</span><br><span class="line"># 查看容器 / 目录下文件</span><br><span class="line">ll</span><br></pre></td></tr></table></figure></li>
<li><p>从容器拷贝到宿主机器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><br><span class="line">#进入容器后创建文件cba.txt</span><br><span class="line">touch cba.txt</span><br><span class="line"># 退出容器</span><br><span class="line">exit</span><br><span class="line"># 在Linux宿主机器执行复制；将容器mycentos2的/cba.txt文件复制到 宿主机器的/root目录下</span><br><span class="line">docker cp mycentos2:/cba.txt /root</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-13-目录挂载"><a href="#4-13-目录挂载" class="headerlink" title="4.13 目录挂载"></a>4.13 目录挂载</h4><ul>
<li><p>可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。</p>
</li>
<li><p>创建容器时添加-v参数，后边为宿主机目录:容器目录，例如： docker run -di -v /usr/local/test:/usr/local/test –name=mycentos3 centos:7</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建linux宿主机器要挂载的目录</span><br><span class="line">mkdir /usr/local/test</span><br><span class="line"># 创建并启动容器mycentos3,并挂载linux中的/usr/local/test目录到容器的/usr/local/test；也就是在</span><br><span class="line">linux中的/usr/local/test中操作相当于对容器相应目录操作</span><br><span class="line">docker run -di -v /usr/local/test:/usr/local/test --name=mycentos3 centos:7</span><br><span class="line"># 在linux下创建文件</span><br><span class="line">touch /usr/local/test/def.txt</span><br><span class="line"># 进入容器</span><br><span class="line">docker exec -it mycentos3 /bin/bash</span><br><span class="line"># 在容器中查看目录中是否有对应文件def.txt</span><br><span class="line">ll /usr/local/test</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-网络"><a href="#5-网络" class="headerlink" title="5.网络"></a>5.网络</h3><h3 id="6-Docker-Compose"><a href="#6-Docker-Compose" class="headerlink" title="6.Docker Compose"></a>6.Docker Compose</h3><h4 id="6-1-compose简介"><a href="#6-1-compose简介" class="headerlink" title="6.1 compose简介"></a>6.1 compose简介</h4><blockquote>
<p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。 </p>
</blockquote>
<blockquote>
<p>使用步骤：</p>
<blockquote>
<ul>
<li>使用 Dockerfile 定义应用程序的环境。</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="6-2-compose的安装"><a href="#6-2-compose的安装" class="headerlink" title="6.2 compose的安装"></a>6.2 compose的安装</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#从Github上下载软件包</span><br><span class="line">$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">#设置文件可执行权限</span><br><span class="line">chomod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">#验证安装是否成功</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="6-3-具体例子"><a href="#6-3-具体例子" class="headerlink" title="6.3 具体例子"></a>6.3 具体例子</h4><h5 id="6-3-1-准备文件"><a href="#6-3-1-准备文件" class="headerlink" title="6.3.1 准备文件"></a>6.3.1 准备文件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir composetest</span><br><span class="line">$ cd composetest</span><br><span class="line">#在该目录下有app.py web应用运行文件，同时包含requirements.txt文佳，里面是两行文本flask、redis。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="6-3-2-Dockerfile文件"><a href="#6-3-2-Dockerfile文件" class="headerlink" title="6.3.2 Dockerfile文件"></a>6.3.2 Dockerfile文件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在 composetest 目录中，创建一个名为 Dockerfile 的文件，用于生成镜像</span><br><span class="line">FROM python:3.7-alpine</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP app.py</span><br><span class="line">ENV FLASK_RUN_HOST 0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">COPY . .</span><br><span class="line">CMD [&quot;flask&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Dockerfile 内容解释：</strong></p>
<ul>
<li><p><strong>FROM python:3.7-alpine</strong>: 从 Python 3.7 映像开始构建镜像。</p>
</li>
<li><p><strong>WORKDIR /code</strong>: 将工作目录设置为 /code。</p>
</li>
<li><p>```<br>ENV FLASK_APP app.py<br>ENV FLASK_RUN_HOST 0.0.0.0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  设置 flask 命令使用的环境变量。</span><br><span class="line"></span><br><span class="line">- **RUN apk add --no-cache gcc musl-dev linux-headers**: 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  COPY requirements.txt requirements.txt</span><br><span class="line">  RUN pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>复制 requirements.txt 并安装 Python 依赖项。</p>
</li>
<li><p><strong>COPY . .</strong>: 将 . 项目中的当前目录复制到 . 镜像中的工作目录。</p>
</li>
<li><p><strong>CMD [“flask”, “run”]</strong>: 容器提供默认的执行命令为：flask run。</p>
</li>
</ul>
<h5 id="6-3-3-配置文件"><a href="#6-3-3-配置文件" class="headerlink" title="6.3.3 配置文件"></a>6.3.3 配置文件</h5><p> 在测试目录中创建一个名为 docker-compose.yml 的文件 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yaml 配置</span><br><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - &quot;5000:5000&quot;</span><br><span class="line">  redis:</span><br><span class="line">    image: &quot;redis:alpine&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该 Compose 文件定义了两个服务：web 和 redis。</p>
<ul>
<li><strong>web</strong>：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。</li>
<li><strong>redis</strong>：该 redis 服务使用 Docker Hub 的公共 Redis 映像。</li>
</ul>
</blockquote>
<h5 id="6-3-4-运行"><a href="#6-3-4-运行" class="headerlink" title="6.3.4 运行"></a>6.3.4 运行</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br><span class="line">#或者后台运行</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h4 id="6-4-配置文件详细参数"><a href="#6-4-配置文件详细参数" class="headerlink" title="6.4  配置文件详细参数"></a>6.4  配置文件详细参数</h4><h5 id="6-4-1-version"><a href="#6-4-1-version" class="headerlink" title="6.4.1 version"></a>6.4.1 version</h5><p> 指定本 yml 依从的 compose 哪个版本制定的。 </p>
<h5 id="6-4-2-指定为构建镜像上下文路径："><a href="#6-4-2-指定为构建镜像上下文路径：" class="headerlink" title="6.4.2  指定为构建镜像上下文路径："></a>6.4.2  指定为构建镜像上下文路径：</h5><p>例如 webapp 服务，指定为从上下文路径 ./dir/Dockerfile 所构建的镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br></pre></td></tr></table></figure>

<p>或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br><span class="line">      labels:</span><br><span class="line">        - &quot;com.example.description=Accounting webapp&quot;</span><br><span class="line">        - &quot;com.example.department=Finance&quot;</span><br><span class="line">        - &quot;com.example.label-with-empty-value&quot;</span><br><span class="line">      target: prod</span><br></pre></td></tr></table></figure>

<ul>
<li>context：上下文路径。</li>
<li>dockerfile：指定构建镜像的 Dockerfile 文件名。</li>
<li>args：添加构建参数，这是只能在构建过程中访问的环境变量。</li>
<li>labels：设置构建镜像的标签。</li>
<li>target：多层构建，可以指定构建哪一层。</li>
</ul>
<h5 id="6-4-3-cap-add，cap-drop"><a href="#6-4-3-cap-add，cap-drop" class="headerlink" title="6.4.3 cap_add，cap_drop"></a>6.4.3 cap_add，cap_drop</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">  - ALL # 开启全部权限</span><br><span class="line"></span><br><span class="line">cap_drop:</span><br><span class="line">  - SYS_PTRACE # 关闭 ptrace权限</span><br></pre></td></tr></table></figure>

<h5 id="6-4-4-cgroup-parent"><a href="#6-4-4-cgroup-parent" class="headerlink" title="6.4.4 cgroup_parent"></a>6.4.4 cgroup_parent</h5><p> 为容器指定父 cgroup 组，意味着将继承该组的资源限制。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cgroup_parent: m-executor-abcd</span><br></pre></td></tr></table></figure>

<h5 id="6-4-5-command"><a href="#6-4-5-command" class="headerlink" title="6.4.5 command"></a>6.4.5 command</h5><p> 覆盖容器启动的默认命令。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</span><br></pre></td></tr></table></figure>

<h5 id="6-4-6-container-name"><a href="#6-4-6-container-name" class="headerlink" title="6.4.6 container_name"></a>6.4.6 container_name</h5><p> 指定自定义容器名称，而不是生成的默认名称。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">container_name: my-web-container</span><br></pre></td></tr></table></figure>

<h5 id="6-4-7-depends-on"><a href="#6-4-7-depends-on" class="headerlink" title="6.4.7 depends_on"></a>6.4.7 depends_on</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置依赖关系。</p>
<ul>
<li>docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。</li>
<li>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。</li>
<li>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。</li>
</ul>
</blockquote>
<p><a href="https://www.runoob.com/docker/docker-compose.html">更多参数访问官网或者菜鸟教程，本问参数参考菜鸟</a></p>
<h3 id="7-卷"><a href="#7-卷" class="headerlink" title="7.卷"></a>7.卷</h3>]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>React入门游戏</title>
    <url>/2022/07/08/React%E5%85%A5%E9%97%A8%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><a href="https://react.docschina.org/tutorial/tutorial.html#picking-a-key">官网的入门教程小游戏</a></p>
<p><code> 游戏规则，“三子棋”</code></p>
<h3 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h3><span id="more"></span>

<blockquote>
<p>其中涉及三个组件，一个函数组件 Square ，两个  React 组件 </p>
</blockquote>
<p>Square 负责渲染每个按钮， Board  负责渲染整个方块，Game组件负责整个棋盘。</p>
<p>函数式组件： 如果你想写的组件只包含一个 <code>render</code> 方法，并且不包含 state，那么使用<strong>函数组件</strong>就会更简单。 </p>
<p>组件之间通过<strong>Props</strong>传递数据， 一个组件接收一些参数，我们把这些参数叫做 <code>props</code>（“props” 是 “properties” 简写） </p>
<p>用<strong>state</strong>实现数据存储，即“记忆功能”（每个组件的私有属性）， 每次在组件中调用 <code>setState</code> 时，React 都会自动更新其子组件 </p>
<h3 id="构建空棋盘流程"><a href="#构建空棋盘流程" class="headerlink" title="构建空棋盘流程"></a>构建空棋盘流程</h3><h4 id="项目启动时"><a href="#项目启动时" class="headerlink" title="项目启动时"></a>项目启动时</h4><p>先进入最顶层的父组件加载构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//history记录每一步后的棋盘布局。一开始棋盘中全部为null</span></span><br><span class="line"><span class="comment">//stepNumber表示 哪一项历史记录，即数组history的下标</span></span><br><span class="line"><span class="comment">//xIsNext表示下一步该谁走，true表示X，false表示O</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">       <span class="variable language_">super</span>(props);</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">           <span class="attr">history</span>: [</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="attr">squares</span>: <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="literal">null</span>)</span><br><span class="line">               &#125;</span><br><span class="line">           ],</span><br><span class="line">           <span class="attr">stepNumber</span>: <span class="number">0</span>,</span><br><span class="line">           <span class="attr">xIsNext</span>: <span class="literal">true</span></span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Game组件render方法进行内容展示"><a href="#Game组件render方法进行内容展示" class="headerlink" title="Game组件render方法进行内容展示"></a>Game组件render方法进行内容展示</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//将state的history变量取出来</span></span><br><span class="line">        <span class="keyword">const</span> history = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">history</span>;</span><br><span class="line">        <span class="comment">//以一开始为例，stempNumber为0，故取数组history中的第一个，即history[0]</span></span><br><span class="line">        <span class="keyword">const</span> current = history[<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">stepNumber</span>];</span><br><span class="line">        <span class="comment">//calculateWinner表示计算谁是获胜者，返回获胜者名称或者null</span></span><br><span class="line">        <span class="keyword">const</span> winner = <span class="title function_">calculateWinner</span>(current.<span class="property">squares</span>);</span><br><span class="line">		<span class="comment">//将每次的描述都赋值给moves，多个&lt;li&gt;</span></span><br><span class="line">        <span class="keyword">const</span> moves = history.<span class="title function_">map</span>(<span class="function">(<span class="params">step, move</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> desc = move ?</span><br><span class="line">                <span class="string">&#x27;Go to move #&#x27;</span> + move :</span><br><span class="line">                <span class="string">&#x27;Go to game start&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;move&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.jumpTo(move)&#125;&gt;&#123;desc&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line">	    <span class="comment">//判读那是否游戏结束，显示相应的信息</span></span><br><span class="line">        <span class="keyword">let</span> status;</span><br><span class="line">        <span class="keyword">if</span> (winner) &#123;</span><br><span class="line">            status = <span class="string">&quot;Winner: &quot;</span> + winner;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            status = <span class="string">&quot;Next player: &quot;</span> + (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">xIsNext</span> ? <span class="string">&quot;X&quot;</span> : <span class="string">&quot;O&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//return里是屏幕上显示的具体内容</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                //棋盘信息</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-board&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Board</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">squares</span>=<span class="string">&#123;current.squares&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">onClick</span>=<span class="string">&#123;i</span> =&gt;</span> this.handleClick(i)&#125;</span></span><br><span class="line"><span class="language-xml">                     /&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">				//游戏进行信息</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;status&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">ol</span>&gt;</span>&#123;moves&#125;<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="进入Board组件render方法"><a href="#进入Board组件render方法" class="headerlink" title="进入Board组件render方法"></a>进入Board组件render方法</h4><p>由于Game组件里面使用Board组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Board</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="comment">//调用Square组件</span></span><br><span class="line">    <span class="title function_">renderSquare</span>(<span class="params">i</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">Square</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">value</span>=<span class="string">&#123;this.props.squares[i]&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.props.onClick(i)&#125;</span></span><br><span class="line"><span class="language-xml">            /&gt;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调用renderSquare方法</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;board-row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;this.renderSquare(0)&#125;</span></span><br><span class="line"><span class="language-xml">                    &#123;this.renderSquare(1)&#125;</span></span><br><span class="line"><span class="language-xml">                    &#123;this.renderSquare(2)&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;board-row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;this.renderSquare(3)&#125;</span></span><br><span class="line"><span class="language-xml">                    &#123;this.renderSquare(4)&#125;</span></span><br><span class="line"><span class="language-xml">                    &#123;this.renderSquare(5)&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;board-row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;this.renderSquare(6)&#125;</span></span><br><span class="line"><span class="language-xml">                    &#123;this.renderSquare(7)&#125;</span></span><br><span class="line"><span class="language-xml">                    &#123;this.renderSquare(8)&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进入Square组件"><a href="#进入Square组件" class="headerlink" title="进入Square组件"></a>进入Square组件</h4><p>由于Board组件里面使用Square组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收参数，返回button，button里面的值是prop.value</span></span><br><span class="line"><span class="comment">//也就Board组件里的value=this.props.squares[i]，以i=0为例，</span></span><br><span class="line"><span class="comment">//value的值是由Gama组件squares=&#123;current.squares&#125;传递给Board的squares</span></span><br><span class="line"><span class="comment">//Board再取squares的第i个(0个)传递给Square的value，值为null</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Square</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;square&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;props.onClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;props.value&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构建了一个空的棋盘"><a href="#构建了一个空的棋盘" class="headerlink" title="构建了一个空的棋盘"></a>构建了一个空的棋盘</h4><h3 id="下棋的时候发生什么"><a href="#下棋的时候发生什么" class="headerlink" title="下棋的时候发生什么"></a>下棋的时候发生什么</h3><h4 id="点击棋盘"><a href="#点击棋盘" class="headerlink" title="点击棋盘"></a>点击棋盘</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点击棋盘时候，触发Square的onclick触发器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Square</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;square&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;props.onClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;props.value&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发Square的onclick触发器,里面是Board传入的函数onClick，故此时调用Board的onClick</span></span><br><span class="line"><span class="title function_">renderSquare</span>(<span class="params">i</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">Square</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">value</span>=<span class="string">&#123;this.props.squares[i]&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.props.onClick(i)&#125;</span></span><br><span class="line"><span class="language-xml">            /&gt;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//同理，Board的onClick里面是Game的handleClick函数</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-board&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Board</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">squares</span>=<span class="string">&#123;current.squares&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">onClick</span>=<span class="string">&#123;i</span> =&gt;</span> this.handleClick(i)&#125;</span></span><br><span class="line"><span class="language-xml">                    /&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;status&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">ol</span>&gt;</span>&#123;moves&#125;<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<h4 id="调用handleClick"><a href="#调用handleClick" class="headerlink" title="调用handleClick"></a>调用handleClick</h4><p>到这一步就是用户点击一个格子，经过三次传递到了handleClick函数。比如点击的是0方格，0方格的Square触发器检测到，找到Board的renderSquare(0)，在找到handleClick(0) </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">handleClick</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="comment">//将history里面所有的下棋记录取出来</span></span><br><span class="line">      <span class="keyword">const</span> history = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">history</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">stepNumber</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//current即当前的棋盘布局</span></span><br><span class="line">    <span class="keyword">const</span> current = history[history.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//取出当前棋盘布局备份</span></span><br><span class="line">      <span class="keyword">const</span> squares = current.<span class="property">squares</span>.<span class="title function_">slice</span>();</span><br><span class="line">    <span class="comment">//如果此时已经有胜者或者点击了有值的格子，则直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">calculateWinner</span>(squares) || squares[i]) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//判断一下点击的格子是X还O并且赋值</span></span><br><span class="line">      squares[i] = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">xIsNext</span> ? <span class="string">&quot;X&quot;</span> : <span class="string">&quot;O&quot;</span>;</span><br><span class="line">    <span class="comment">//讲此时组件内值重新设计，此时该组件和其子组件会重新刷新</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="comment">//history后加了一天记录</span></span><br><span class="line">          <span class="attr">history</span>: history.<span class="title function_">concat</span>([</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="attr">squares</span>: squares</span><br><span class="line">              &#125;</span><br><span class="line">          ]),</span><br><span class="line">          <span class="comment">//历史长度+1，即当前走的步数+1</span></span><br><span class="line">          <span class="attr">stepNumber</span>: history.<span class="property">length</span>,</span><br><span class="line">          <span class="comment">//下一步该谁走变一下</span></span><br><span class="line">          <span class="attr">xIsNext</span>: !<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">xIsNext</span></span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="重新加载Gama及其子组件"><a href="#重新加载Gama及其子组件" class="headerlink" title="重新加载Gama及其子组件"></a>重新加载Gama及其子组件</h4><p>即就是重新构建棋盘，步骤和构建空棋盘差不多，只不过此时squares不是全为null，而是里面有值了。</p>
<h3 id="在游戏历史记录列表显示每一步棋的坐标"><a href="#在游戏历史记录列表显示每一步棋的坐标" class="headerlink" title="在游戏历史记录列表显示每一步棋的坐标"></a>在游戏历史记录列表显示每一步棋的坐标</h3><p>格式为 (列号, 行号) ,思路是在Game组件中记录每次下棋的位置，类似history一样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//1.构造函数 state属性上 加上currentPoint表示当前下棋的坐标</span></span><br><span class="line"> <span class="attr">currentPoint</span>: []</span><br><span class="line"> <span class="comment">//2.每次下棋之后，将当前坐标加上去(数组类型)</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">history</span>: history.<span class="title function_">concat</span>([</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">squares</span>: squares</span><br><span class="line">                &#125;</span><br><span class="line">            ]),</span><br><span class="line">            <span class="attr">stepNumber</span>: history.<span class="property">length</span>,</span><br><span class="line">            <span class="attr">xIsNext</span>: !<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">xIsNext</span>,</span><br><span class="line">            <span class="attr">currentPoint</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">currentPoint</span>.<span class="title function_">concat</span>(i),</span><br><span class="line">        &#125;);</span><br><span class="line"> <span class="comment">//3.render方法中在每个步骤之后，根据currentPoint计算横纵坐标进行显示</span></span><br><span class="line">  <span class="keyword">const</span> moves = history.<span class="title function_">map</span>(<span class="function">(<span class="params">step, move</span>) =&gt;</span> &#123;</span><br><span class="line">            move=<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isHistoryAsc</span>?<span class="attr">move</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">history</span>.<span class="property">length</span> - <span class="number">1</span>-move</span><br><span class="line">            <span class="keyword">const</span> desc = move ?</span><br><span class="line">                <span class="string">&#x27;Go to move #&#x27;</span> + move :</span><br><span class="line">                <span class="string">&#x27;Go to game start&#x27;</span>;</span><br><span class="line">            <span class="keyword">const</span>  bold=move===history.<span class="property">length</span>-<span class="number">1</span>?<span class="language-xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;desc&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span>:desc;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;move&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.jumpTo(move)&#125;&gt;&#123;bold&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        ---------这一步的坐标是(&#123;calcRowPoint(this.state.currentPoint[move - 1])[0]&#125;,&#123;calcRowPoint(this.state.currentPoint[move - 1])[1]&#125;)</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line"> <span class="comment">//4.calcRowPoint为自己定义的，根据数组坐标计算棋盘上横纵坐标的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calcRowPoint</span>(<span class="params">point</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(point===<span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> row=<span class="title class_">Math</span>.<span class="title function_">floor</span>(point/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> line=point%<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> [line,row];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在历史记录列表中加粗显示当前选择的项目"><a href="#在历史记录列表中加粗显示当前选择的项目" class="headerlink" title="在历史记录列表中加粗显示当前选择的项目"></a>在历史记录列表中加粗显示当前选择的项目</h3><p>就是进行到哪一步，历史记录列表中的哪一项进行加粗</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单的判断一下 当前步骤move是否是历史步骤的最后一个即可</span></span><br><span class="line"><span class="keyword">const</span> moves = history.<span class="title function_">map</span>(<span class="function">(<span class="params">step, move</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> desc = move ?</span><br><span class="line">                <span class="string">&#x27;Go to move #&#x27;</span> + move :</span><br><span class="line">                <span class="string">&#x27;Go to game start&#x27;</span>;</span><br><span class="line">            <span class="keyword">const</span>  bold=move===history.<span class="property">length</span>-<span class="number">1</span>?<span class="language-xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;desc&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span>:desc;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;move&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.jumpTo(move)&#125;&gt;&#123;bold&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        ---------这一步的坐标是(&#123;calcRowPoint(this.state.currentPoint[move - 1])[0]&#125;,&#123;calcRowPoint(this.state.currentPoint[move - 1])[1]&#125;)</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="使用两个循环来渲染出棋盘的格子"><a href="#使用两个循环来渲染出棋盘的格子" class="headerlink" title="使用两个循环来渲染出棋盘的格子"></a>使用两个循环来渲染出棋盘的格子</h3><p>两个for循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Board组件中</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 采用循环生成九宫格</span></span><br><span class="line">        <span class="keyword">const</span> boardLine = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">item, itemIndex</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;board-row&quot;</span> <span class="attr">key</span>=<span class="string">&#123;itemIndex&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;[1, 2, 3].map((numbers, numIndex) =&gt; this.renderSquare(item * 3 - (3 - numbers) - 1))&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;boardLine&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="添加一个可以升序或降序显示历史记录的按钮"><a href="#添加一个可以升序或降序显示历史记录的按钮" class="headerlink" title="添加一个可以升序或降序显示历史记录的按钮"></a>添加一个可以升序或降序显示历史记录的按钮</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//总体思路：改变渲染顺序即可</span></span><br><span class="line"><span class="comment">//增加一个button，在Game的render的return结果中</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-board&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Board</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">squares</span>=<span class="string">&#123;current.squares&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">onClick</span>=<span class="string">&#123;i</span> =&gt;</span> this.handleClick(i)&#125;</span></span><br><span class="line"><span class="language-xml">                    /&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;status&#125;-----</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;this.changeOrder();&#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                            历史记录&#123;this.state.isHistoryAsc ? &#x27;升序&#x27; : &#x27;降序&#x27;&#125;排列</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">ol</span>&gt;</span>&#123;moves&#125;<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;tieResult &amp;&amp; (</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>平局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                )&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line"><span class="comment">//Game的构造函数state中增加属性isHistoryAsc</span></span><br><span class="line"><span class="attr">isHistoryAsc</span>:<span class="literal">true</span></span><br><span class="line"><span class="comment">//增加一个改变这个属性的方法</span></span><br><span class="line"><span class="comment">// 切换升序降序</span></span><br><span class="line">    <span class="title function_">changeOrder</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state</span>)=&gt;</span>(&#123; <span class="attr">isHistoryAsc</span>:!<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isHistoryAsc</span> &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//显示的时候判断一下</span></span><br><span class="line"><span class="keyword">const</span> moves = history.<span class="title function_">map</span>(<span class="function">(<span class="params">step, move</span>) =&gt;</span> &#123;</span><br><span class="line">            move=<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isHistoryAsc</span>?<span class="attr">move</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">history</span>.<span class="property">length</span> - <span class="number">1</span>-move</span><br><span class="line">            <span class="keyword">const</span> desc = move ?</span><br><span class="line">                <span class="string">&#x27;Go to move #&#x27;</span> + move :</span><br><span class="line">                <span class="string">&#x27;Go to game start&#x27;</span>;</span><br><span class="line">            <span class="keyword">const</span>  bold=move===history.<span class="property">length</span>-<span class="number">1</span>?<span class="language-xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;desc&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span>:desc;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;move&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.jumpTo(move)&#125;&gt;&#123;bold&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        ---------这一步的坐标是(&#123;calcRowPoint(this.state.currentPoint[move - 1])[0]&#125;,&#123;calcRowPoint(this.state.currentPoint[move - 1])[1]&#125;)</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="每当有人获胜时，高亮显示连成一线的-3-颗棋子"><a href="#每当有人获胜时，高亮显示连成一线的-3-颗棋子" class="headerlink" title="每当有人获胜时，高亮显示连成一线的 3 颗棋子"></a>每当有人获胜时，高亮显示连成一线的 3 颗棋子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//胜利时判断出哪三个棋子，然后进行高亮就行</span></span><br><span class="line"><span class="comment">//修改判断胜利者的返回格式，除了返回谁是胜利者，还要返回坐标</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateWinner</span>(<span class="params">squares</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> lines = [</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">        [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lines.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> [a, b, c] = lines[i];</span><br><span class="line">        <span class="keyword">if</span> (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">winner</span>:squares[a],</span><br><span class="line">                <span class="attr">point</span>:[a,b,c]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//修改之前调用calculateWinner的地方</span></span><br><span class="line"><span class="comment">//Game的render方法</span></span><br><span class="line"><span class="keyword">const</span> winnerResult = <span class="title function_">calculateWinner</span>(current.<span class="property">squares</span>);</span><br><span class="line">        <span class="keyword">const</span>  winner = winnerResult?.<span class="property">winner</span>;</span><br><span class="line"><span class="comment">//Game的handleClick(i) 方法    </span></span><br><span class="line"> <span class="keyword">if</span> (<span class="title function_">calculateWinner</span>(squares)?.<span class="property">winner</span> || squares[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//Game传递胜利者坐标 没有则为[]</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-board&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Board</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">squares</span>=<span class="string">&#123;current.squares&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">onClick</span>=<span class="string">&#123;i</span> =&gt;</span> this.handleClick(i)&#125;</span></span><br><span class="line"><span class="language-xml">                        point=&#123;winnerResult?.point || []&#125;</span></span><br><span class="line"><span class="language-xml">                    /&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;status&#125;-----</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;this.changeOrder();&#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                            历史记录&#123;this.state.isHistoryAsc ? &#x27;升序&#x27; : &#x27;降序&#x27;&#125;排列</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">ol</span>&gt;</span>&#123;moves&#125;<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line"><span class="comment">//Board进行参数接受</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-board&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Board</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">squares</span>=<span class="string">&#123;current.squares&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">onClick</span>=<span class="string">&#123;i</span> =&gt;</span> this.handleClick(i)&#125;</span></span><br><span class="line"><span class="language-xml">                        point=&#123;winnerResult?.point || []&#125;</span></span><br><span class="line"><span class="language-xml">                    /&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;status&#125;-----</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;this.changeOrder();&#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                            历史记录&#123;this.state.isHistoryAsc ? &#x27;升序&#x27; : &#x27;降序&#x27;&#125;排列</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">ol</span>&gt;</span>&#123;moves&#125;<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;tieResult &amp;&amp; (</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>平局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                )&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="当无人获胜时，显示一个平局的消息。"><a href="#当无人获胜时，显示一个平局的消息。" class="headerlink" title="当无人获胜时，显示一个平局的消息。"></a>当无人获胜时，显示一个平局的消息。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//加上一个判断即可</span><br><span class="line">let status;</span><br><span class="line">let tieResult = false;</span><br><span class="line">if (winner) &#123;</span><br><span class="line">    status = &quot;Winner: &quot; + winner;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   status = &quot;Next player: &quot; + (this.state.xIsNext ? &quot;X&quot; : &quot;O&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">if(current.squares.every((item)=&gt;item)&amp;&amp;!winner)&#123;</span><br><span class="line">    tieResult=true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//显示</span><br><span class="line">  return (</span><br><span class="line">            &lt;div className=&quot;game&quot;&gt;</span><br><span class="line">                &lt;div className=&quot;game-board&quot;&gt;</span><br><span class="line">                    &lt;Board</span><br><span class="line">                        squares=&#123;current.squares&#125;</span><br><span class="line">                        onClick=&#123;i =&gt; this.handleClick(i)&#125;</span><br><span class="line">                        point=&#123;winnerResult?.point || []&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div className=&quot;game-info&quot;&gt;</span><br><span class="line">                    &lt;div&gt;&#123;status&#125;-----</span><br><span class="line">                        &lt;button onClick=&#123;() =&gt; &#123;this.changeOrder();&#125;&#125;&gt;</span><br><span class="line">                            历史记录&#123;this.state.isHistoryAsc ? &#x27;升序&#x27; : &#x27;降序&#x27;&#125;排列</span><br><span class="line">                        &lt;/button&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;ol&gt;&#123;moves&#125;&lt;/ol&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &#123;tieResult &amp;&amp; (</span><br><span class="line">                    &lt;div&gt;</span><br><span class="line">                        &lt;h1&gt;平局&lt;/h1&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                )&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>stream</title>
    <url>/2022/04/01/stream/</url>
    <content><![CDATA[<h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等—不可以是map！！</li>
<li><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。l</li>
</ul>
 <span id="more"></span> 

<h4 id="接口继承关系图："><a href="#接口继承关系图：" class="headerlink" title="接口继承关系图："></a>接口继承关系图：</h4><p><img src="/stream%5C1623152105(1).jpg" alt="流接口图"></p>
<img src="/2022/04/01/stream/1623152105(1).jpg" class title="stream接口图">

<p>图中4种<em>stream</em>接口继承自<code>BaseStream</code>，其中<code>IntStream, LongStream, DoubleStream</code>对应三种基本类型（<code>int, long, double</code>，注意不是包装类型），<code>Stream</code>对应所有剩余类型的<em>stream</em>视图。为不同数据类型设置不同<em>stream</em>接口，可以1.提高性能，2.增加特定接口函数。</p>
<h4 id="和collections的比较"><a href="#和collections的比较" class="headerlink" title="和collections的比较"></a>和collections的比较</h4><ul>
<li><strong>无存储</strong>。<em>stream</em>不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>
<li><strong>为函数式编程而生</strong>。对<em>stream</em>的任何修改都不会修改背后的数据源，比如对<em>stream</em>执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新<em>stream</em>。</li>
<li><strong>惰式执行</strong>。<em>stream</em>上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>
<li><strong>可消费性</strong>。<em>stream</em>只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>
</ul>
<h4 id="常见api："><a href="#常见api：" class="headerlink" title="常见api："></a>常见api：</h4><p>对<em>stream</em>的操作分为为两类，**中间操作(*intermediate operations*)和结束操作(*terminal operations*)**，二者特点是：</p>
<ol>
<li><strong>中间操作总是会惰式执行</strong>，调用中间操作只会生成一个标记了该操作的新<em>stream</em>，仅此而已。</li>
<li><strong>结束操作会触发实际计算</strong>，计算发生时会把所有中间操作积攒的操作以<em>pipeline</em>的方式执行，这样可以减少迭代次数。计算完成之后<em>stream</em>就会失效。</li>
</ol>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>接口方法</th>
</tr>
</thead>
<tbody><tr>
<td>中间操作</td>
<td>concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()</td>
</tr>
<tr>
<td>结束操作</td>
<td>allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()</td>
</tr>
</tbody></table>
<p>区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为<em>stream</em>的大都是中间操作，否则是结束操作。</p>
<h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Stream.forEach()迭代</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保留长度等于3的字符串</span></span><br><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.filter(str -&gt; str.length()==<span class="number">3</span>)</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<h5 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.distinct()</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br><span class="line"><span class="comment">//去重 将第二个too去掉</span></span><br></pre></td></tr></table></figure>

<h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h5><p>排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为<code>Stream&lt;T&gt;　sorted()</code>和<code>Stream&lt;T&gt;　sorted(Comparator&lt;? super T&gt; comparator)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.sorted((str1, str2) -&gt; str1.length()-str2.length())</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br><span class="line"><span class="comment">//按照长度升序排序</span></span><br></pre></td></tr></table></figure>

<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>函数原型为<code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</code>，作用是返回一个对当前所有元素执行执行<code>mapper</code>之后的结果组成的<code>Stream</code>。直观的说，就是对每个元素按照某种操作进行转换，转换前后<code>Stream</code>中元素的个数不会改变，但元素的类型取决于转换之后的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream　= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.map(str -&gt; str.toUpperCase())</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>

<p>项目常用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;ADto&gt; rules = elist.stream().map(e -&gt; &#123;</span><br><span class="line">            <span class="type">ADto</span> <span class="variable">aDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ADto</span>();</span><br><span class="line">            aDto.setBagId(e.getBagId());</span><br><span class="line">            aDto.setLocale(e.getLocale());</span><br><span class="line">            aDto.setRuleId(e.getRuleId());</span><br><span class="line">            <span class="keyword">return</span> aDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//或者封装一个方法</span></span><br><span class="line">List&lt;ADto&gt; rules = elist.stream().map(e -&gt; convertA(e)</span><br><span class="line">        ).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h5 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h5><p><code>Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)</code></p>
<blockquote>
<p>map和peek的区别</p>
</blockquote>
<p>首先看定义</p>
<blockquote>
<p> Stream<T> peek(Consumer&lt;? super T&gt; action);</T></p>
<p> peek方法接收一个Consumer的入参。了解λ表达式的应该明白 Consumer的实现类 应该只有一个方法，该方法返回类型为void如:Consumer<Integer> c =  i -&gt; System.out.println(“hello” + i);</Integer></p>
</blockquote>
<blockquote>
<p>map方法的入参为 Function。<R> Stream<R> map(Function&lt;? super T, ? extends R&gt; mapper);</R></R></p>
<p>Function 的 λ表达式 可以这样写Function&lt;Integer,String&gt; f = x -&gt; {return  “hello” + i;};</p>
</blockquote>
<p>map函数对Stream中元素执行的是映射操作，会以新的元素(map的结果)填充新的Stream，严格的讲map不是修改原来的元素。peek只能消费Stream中的元素，是否可以更该Stream中的元素，取决于Stream中的元素是否是不可变对象。如果是不可变对象，则不可修改Stream中的元素；如果是可变对象，则可以修改对象的值，但是无法修改对象的引用.</p>
<p>不可变对象:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Stream.of(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>)</span><br><span class="line">        .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line">        .peek(s -&gt; &#123;</span><br><span class="line">            s = s + <span class="string">&quot;-&quot;</span> + s;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;)</span><br><span class="line">        .map(String::toUpperCase)</span><br><span class="line">        .peek(e -&gt; System.out.println(<span class="string">&quot;Mapped value: &quot;</span> + e))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">three-three</span><br><span class="line">Mapped value: THREE</span><br><span class="line">four-four</span><br><span class="line">Mapped value: FOUR</span><br><span class="line">[THREE, FOUR]</span><br></pre></td></tr></table></figure>

<p>可变对象:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//peek常用案例</span></span><br><span class="line">  List&lt;User&gt; userList=Stream.of(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;a&quot;</span>),<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;b&quot;</span>),<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;c&quot;</span>)).peek(u-&gt;u.setName(<span class="string">&quot;kkk&quot;</span>)).collect(Collectors.toList());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,userList);</span><br><span class="line"><span class="comment">//10:25:59.784 [main] INFO com.flydean.PeekUsage - [PeekUsage.User(name=kkk), PeekUsage.User(name=kkk), PeekUsage.User(name=kkk)]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="flatmap"><a href="#flatmap" class="headerlink" title="flatmap"></a>flatmap</h5><p>函数原型为<code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code>，作用是对每个元素执行<code>mapper</code>指定的操作，并用所有<code>mapper</code>返回的<code>Stream</code>中的元素组成一个新的<code>Stream</code>作为最终返回结果。说起来太拗口，通俗的讲<code>flatMap()</code>的作用就相当于把原<em>stream</em>中的所有元素都”摊平”之后组成的<code>Stream</code>，转换前后元素的个数和类型都可能会改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>), Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">stream.flatMap(list -&gt; list.stream())</span><br><span class="line">    .forEach(i -&gt; System.out.println(i));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中，原来的<code>stream</code>中有两个元素，分别是两个<code>List&lt;Integer&gt;</code>，执行<code>flatMap()</code>之后，将每个<code>List</code>都“摊平”成了一个个的数字，所以会新产生一个由5个数字组成的<code>Stream</code>。所以最终将输出1~5这5个数字。</p>
<p>形象的例子：</p>
<p>现在学校通知关于数学教学的通知给家长。思路：找到所有教数学的老师，找到老师教的学生，找到学生的家长进行通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到所有数学老师的学生的家长的电话,并找他们开家长会</span></span><br><span class="line">        List&lt;Parents&gt; collect = teacs.stream()</span><br><span class="line">                <span class="comment">// 过滤数学老师</span></span><br><span class="line">                .filter(t -&gt; Subject.Math.getValue().equals(t.getSubject()))</span><br><span class="line">                <span class="comment">// 通过老师找学生</span></span><br><span class="line">                .flatMap(t -&gt; stus.stream().filter(s -&gt; s.getTechId().equals(t.getId())))</span><br><span class="line">                <span class="comment">// 过滤重复的学生(使用student的equals和hashCode方法)</span></span><br><span class="line">                .distinct()</span><br><span class="line">                <span class="comment">// 通过学生找家长(这里就简化为创建家长对象)</span></span><br><span class="line">                .map(s -&gt; &#123;</span><br><span class="line">                    <span class="type">Parents</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parents</span>();</span><br><span class="line">                    p.setId(UUID.randomUUID().toString());</span><br><span class="line">                    p.setChirldId(s.getId());</span><br><span class="line">                    p.setName(s.getName().toUpperCase() + <span class="string">&quot;&#x27;s Parent&quot;</span>);</span><br><span class="line">                    p.setEmail((<span class="type">int</span>) (Math.random() * <span class="number">1000000</span>) + <span class="string">&quot;@qq.com&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 打印到控制台看看</span></span><br><span class="line">        collect.stream()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于调用flatmap的流的每一个元素，执行flatmap入参中的函数式方法，由于该函数式方法必须返回一个stream<T>类型的流，这样对于调用flatmap的操作来说，就收集了另一种类型(<T>)的流，并在后续的操作中将<T>类型进行合并，最终产生一个stream<T>的流，而不是一个stream&lt;stream<T>&gt;类型的流。</T></T></T></T></T></p>
<h4 id="规约操作"><a href="#规约操作" class="headerlink" title="规约操作"></a>规约操作</h4><p>规约操作（<em>reduction operation</em>）又被称作折叠操作（<em>fold</em>），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。<em>Stream</em>类库有两个通用的规约操作<code>reduce()</code>和<code>collect()</code>，也有一些为简化书写而设计的专用规约操作，比如<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等。</p>
<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></p>
<p><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></p>
<p><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code></p>
<p>！！擅长生成一个值！！</p>
<p><code>reduce()</code>最常用的场景就是从一堆值中生成一个值。用这么复杂的函数去求一个最大或最小值，你是不是觉得设计者有病。其实不然，因为“大”和“小”或者“求和”有时会有不同的语义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找出最长的单词</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class="line"><span class="comment">//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());</span></span><br><span class="line">System.out.println(longest.get());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求出一组单词的长度之和。这是个“求和”操作，操作对象输入类型是String，而结果类型是Integer。</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">lengthSum</span> <span class="operator">=</span> stream.reduce(<span class="number">0</span>,　<span class="comment">// 初始值　// (1)</span></span><br><span class="line">        (sum, str) -&gt; sum+str.length()) <span class="comment">// 累加器 // (2)</span></span><br><span class="line"> <span class="comment">//       (a, b) -&gt; a+b);　</span></span><br><span class="line"><span class="comment">// int lengthSum = stream.mapToInt(str -&gt; str.length()).sum();</span></span><br><span class="line">System.out.println(lengthSum);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//下面的代码演示了如何将配置文件的每一行配置通过map()和reduce()操作聚合成一个Map&lt;String, String&gt;：</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 按行读取配置文件:</span><br><span class="line">        List&lt;String&gt; props = List.of(&quot;profile=native&quot;, &quot;debug=true&quot;, &quot;logging=warn&quot;, &quot;interval=500&quot;);</span><br><span class="line">        Map&lt;String, String&gt; map = props.stream()</span><br><span class="line">                // 把k=v转换为Map[k]=v:</span><br><span class="line">                .map(kv -&gt; &#123;</span><br><span class="line">                    String[] ss = kv.split(&quot;\\=&quot;, 2);</span><br><span class="line">                    return Map.of(ss[0], ss[1]);</span><br><span class="line">                &#125;)</span><br><span class="line">                // 把所有Map聚合到一个Map:</span><br><span class="line">                .reduce(new HashMap&lt;String, String&gt;(), (m, kv) -&gt; &#123;</span><br><span class="line">                    m.putAll(kv);</span><br><span class="line">                    return m;</span><br><span class="line">                &#125;);</span><br><span class="line">        // 打印结果:</span><br><span class="line">        map.forEach((k, v) -&gt; &#123;</span><br><span class="line">            System.out.println(k + &quot; = &quot; + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="collect！！！！！！"><a href="#collect！！！！！！" class="headerlink" title="collect！！！！！！"></a>collect！！！！！！</h5><p>！！擅长生成一个集合或者是Map等复杂对象！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将Stream转换成容器或Map</span></span><br><span class="line"><span class="comment">//上述代码分别列举了如何将Stream转换成List、Set和Map</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList()); <span class="comment">// (1)</span></span><br><span class="line"><span class="comment">// Set&lt;String&gt; set = stream.collect(Collectors.toSet()); // (2)</span></span><br><span class="line"><span class="comment">// Map&lt;String, Integer&gt; map = stream.collect(Collectors.toMap(Function.identity(), String::length)); // (3)</span></span><br><span class="line"><span class="comment">//System.out.println(map);</span></span><br><span class="line"><span class="comment">//&#123;love=4, too=3, I=1, you=3&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>Function</em>是一个接口，那么<code>Function.identity()</code>是什么意思呢？这要从两方面解释：</p>
</blockquote>
<ol>
<li>Java 8允许在接口中加入具体方法。接口中的具体方法有两种，<em>default</em>方法和<em>static</em>方法，<code>identity()</code>就是<em>Function</em>接口的一个静态方法。</li>
<li><code>Function.identity()</code>是Lambda表达式对象，意思是返回的输出和输入一样，等价于形如<code>t -&gt; t</code>形式的Lambda表达式。</li>
</ol>
<blockquote>
<p>::</p>
</blockquote>
<p>诸如<code>String::length</code>的语法形式叫做方法引用（<em>method references</em>），这种语法用来替代某些特定形式Lambda表达式。如果Lambda表达式的全部内容就是调用一个已有的方法，那么可以用方法引用来替代Lambda表达式。方法引用可以细分为四类：</p>
<table>
<thead>
<tr>
<th>方法引用类别</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>引用静态方法</td>
<td><code>Integer::sum</code></td>
</tr>
<tr>
<td>引用某个对象的方法</td>
<td><code>list::add</code></td>
</tr>
<tr>
<td>引用某个类的方法</td>
<td><code>String::length</code></td>
</tr>
<tr>
<td>引用构造方法</td>
<td><code>HashMap::new</code></td>
</tr>
</tbody></table>
<blockquote>
<p>转成list，set</p>
</blockquote>
<p><em>collect()<em>方法定义为<code>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code>，三个参数依次对应上述三条分析。不过每次调用</em>collect()<em>都要传入这三个参数太麻烦，收集器</em>Collector</em>就是对这三个参数的简单封装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//　将Stream规约成List</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);<span class="comment">// 方式１</span></span><br><span class="line"><span class="comment">//List&lt;String&gt; list = stream.collect(Collectors.toList());// 方式2</span></span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当想要确切的制定返回的类型，而不是接口类型的时候</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用toCollection()指定规约容器的类型</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));<span class="comment">// (3)</span></span><br><span class="line">HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));<span class="comment">// (4)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>转成map</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用toMap()统计学生GPA</span></span><br><span class="line">Map&lt;Student, Double&gt; studentToGPA =</span><br><span class="line">     students.stream().collect(Collectors.toMap(Functions.identity(),<span class="comment">// 如何生成key</span></span><br><span class="line">                                     student -&gt; computeGPA(student)));<span class="comment">// 如何生成value</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Partition students into passing and failing</span></span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()</span><br><span class="line">         .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Group employees by department</span></span><br><span class="line">Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getDepartment));</span><br><span class="line"><span class="comment">//增强版groupingBy</span></span><br><span class="line"><span class="comment">// 使用下游收集器统计每个部门的人数</span></span><br><span class="line">Map&lt;Department, Integer&gt; totalByDept = employees.stream()</span><br><span class="line">                    .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                                                   Collectors.counting()));<span class="comment">// 下游收集器</span></span><br><span class="line"><span class="comment">//下游收集器还可以有更下游的收集器</span></span><br><span class="line"><span class="comment">// 按照部门对员工分布组，并只保留员工的名字</span></span><br><span class="line">Map&lt;Department, List&lt;String&gt;&gt; byDept = employees.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                        Collectors.mapping(Employee::getName,<span class="comment">// 下游收集器</span></span><br><span class="line">                                Collectors.toList())));<span class="comment">// 更下游的收集器</span></span><br><span class="line">                               </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Collectors.joining()</span></span><br><span class="line"><span class="comment">// 使用Collectors.joining()拼接字符串</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>);</span><br><span class="line"><span class="comment">//String joined = stream.collect(Collectors.joining());// &quot;Iloveyou&quot;</span></span><br><span class="line"><span class="comment">//String joined = stream.collect(Collectors.joining(&quot;,&quot;));// &quot;I,love,you&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">joined</span> <span class="operator">=</span> stream.collect(Collectors.joining(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>));<span class="comment">// &quot;&#123;I,love,you&#125;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h4><p>收集器（<em>Collector</em>）是为<code>Stream.collect()</code>方法量身打造的工具接口（类）。考虑一下将一个<em>Stream</em>转换成一个容器（或者<em>Map</em>）需要做哪些工作？我们至少需要两样东西：</p>
<ol>
<li>目标容器是什么？是<em>ArrayList</em>还是<em>HashSet</em>，或者是个<em>TreeMap</em>。</li>
<li>新元素如何添加到容器中？是<code>List.add()</code>还是<code>Map.put()</code></li>
</ol>
<p>如果并行的进行规约，还需要告诉<em>collect()</em> 3. 多个部分结果如何合并成一个。</p>
<p>详情见上面的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8TestStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用 Java 7: &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算空字符串</span></span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;列表: &quot;</span> +strings);</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> getCountEmptyStringUsingJava7(strings);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;空字符数量为: &quot;</span> + count);</span><br><span class="line">        count = getCountLength3UsingJava7(strings);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度为 3 的数量为: &quot;</span> + count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除空字符串</span></span><br><span class="line">        List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings);</span><br><span class="line">        System.out.println(<span class="string">&quot;筛选后的列表: &quot;</span> + filtered);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除空字符串，并使用逗号把它们合并起来</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mergedString</span> <span class="operator">=</span> getMergedStringUsingJava7(strings,<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;合并字符串: &quot;</span> + mergedString);</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取列表元素平方数</span></span><br><span class="line">        List&lt;Integer&gt; squaresList = getSquares(numbers);</span><br><span class="line">        System.out.println(<span class="string">&quot;平方数列表: &quot;</span> + squaresList);</span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">17</span>,<span class="number">8</span>,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;列表: &quot;</span> +integers);</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + getMax(integers));</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + getMin(integers));</span><br><span class="line">        System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + getSum(integers));</span><br><span class="line">        System.out.println(<span class="string">&quot;平均数 : &quot;</span> + getAverage(integers));</span><br><span class="line">        System.out.println(<span class="string">&quot;随机数: &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出10个随机数</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            System.out.println(random.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 Java 8: &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;列表: &quot;</span> +strings);</span><br><span class="line">		<span class="comment">//过滤器！！！！！</span></span><br><span class="line">        count = strings.stream().filter(string-&gt;string.isEmpty()).count();</span><br><span class="line">        System.out.println(<span class="string">&quot;空字符串数量为: &quot;</span> + count);</span><br><span class="line"></span><br><span class="line">        count = strings.stream().filter(string -&gt; string.length() == <span class="number">3</span>).count();</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度为 3 的数量为: &quot;</span> + count);</span><br><span class="line">		</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//过滤器后转化为其他类型</span></span><br><span class="line">        filtered = strings.stream().filter(string -&gt;!string.isEmpty()).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;筛选后的列表: &quot;</span> + filtered);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	//用这种方法也已将类集合选择其中两个属性转化为map形式</span></span><br><span class="line"><span class="comment">	Map&lt;String, String&gt; map = tagsList.stream().collect(Collectors.toMap(Tag::getTagName, Tag::getTagColor));</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        mergedString = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;合并字符串: &quot;</span> + mergedString);</span><br><span class="line"></span><br><span class="line">        squaresList = numbers.stream().map( i -&gt;i*i).distinct().collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;Squares List: &quot;</span> + squaresList);</span><br><span class="line">        System.out.println(<span class="string">&quot;列表: &quot;</span> +integers);</span><br><span class="line"></span><br><span class="line">        <span class="type">IntSummaryStatistics</span> <span class="variable">stats</span> <span class="operator">=</span> integers.stream().mapToInt((x) -&gt;x).summaryStatistics();</span><br><span class="line">        List&lt;Integer&gt; reverseIntegers = integers.stream().map(i -&gt; i * i).sorted((x, y) -&gt; y - x).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;数字平方倒序输出：&quot;</span>+reverseIntegers);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + stats.getMax());</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + stats.getMin());</span><br><span class="line">        System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + stats.getSum());</span><br><span class="line">        System.out.println(<span class="string">&quot;平均数 : &quot;</span> + stats.getAverage());</span><br><span class="line">        System.out.println(<span class="string">&quot;随机数: &quot;</span>);</span><br><span class="line"></span><br><span class="line">        random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并行处理</span></span><br><span class="line">        count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">        System.out.println(<span class="string">&quot;空字符串的数量为: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCountEmptyStringUsingJava7</span><span class="params">(List&lt;String&gt; strings)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String string: strings)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(string.isEmpty())&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCountLength3UsingJava7</span><span class="params">(List&lt;String&gt; strings)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String string: strings)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(string.length() == <span class="number">3</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">deleteEmptyStringsUsingJava7</span><span class="params">(List&lt;String&gt; strings)</span>&#123;</span><br><span class="line">        List&lt;String&gt; filteredList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String string: strings)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!string.isEmpty())&#123;</span><br><span class="line">                filteredList.add(string);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filteredList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getMergedStringUsingJava7</span><span class="params">(List&lt;String&gt; strings, String separator)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String string: strings)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!string.isEmpty())&#123;</span><br><span class="line">                stringBuilder.append(string);</span><br><span class="line">                stringBuilder.append(separator);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mergedString</span> <span class="operator">=</span> stringBuilder.toString();</span><br><span class="line">        <span class="keyword">return</span> mergedString.substring(<span class="number">0</span>, mergedString.length()-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">getSquares</span><span class="params">(List&lt;Integer&gt; numbers)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; squaresList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Integer number: numbers)&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">square</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(number.intValue() * number.intValue());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!squaresList.contains(square))&#123;</span><br><span class="line">                squaresList.add(square);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> squaresList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(List&lt;Integer&gt; numbers)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> numbers.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i &lt; numbers.size();i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> numbers.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(number.intValue() &gt; max)&#123;</span><br><span class="line">                max = number.intValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">(List&lt;Integer&gt; numbers)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> numbers.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i &lt; numbers.size();i++)&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> numbers.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(number.intValue() &lt; min)&#123;</span><br><span class="line">                min = number.intValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(List numbers)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">int</span>)(numbers.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i &lt; numbers.size();i++)&#123;</span><br><span class="line">            sum += (<span class="type">int</span>)numbers.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getAverage</span><span class="params">(List&lt;Integer&gt; numbers)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(numbers) / numbers.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
</search>
